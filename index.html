<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP DIGITAL | Kawaii Deep Sea v3.8</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&family=Syne:wght@400..800&family=Manrope:wght@200..800&family=Zen+Maru+Gothic:wght@400;700;900&family=Nosifer&family=Rubik+Glitch&family=Oswald:wght@500;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/studio-freight/lenis@1.0.29/bundled/lenis.min.js"></script>
    
    <!-- Markdown Parser for Chat -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
 
    <script>
        // Error Handling for Libraries
        window.addEventListener('error', function(e) {
            console.error("Global Error:", e.message);
        });
        
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Manrope"', '"Zen Maru Gothic"', 'sans-serif'],
                        display: ['"Syne"', 'sans-serif'],
                        serif: ['"Cinzel"', 'serif'],
                        cute: ['"Zen Maru Gothic"', 'sans-serif'],
                        horror: ['"Nosifer"', 'cursive'],
                        glitch: ['"Rubik Glitch"', 'cursive'],
                        impact: ['"Oswald"', 'sans-serif'],
                        tech: ['"Share Tech Mono"', 'monospace'],
                    },
                    colors: {
                        void: '#050510',
                        biolum: '#4CC9F0',
                        biolum2: '#4361EE',
                        biolum3: '#F72585',
                        kawaii_p: '#FF99C8',
                        kawaii_c: '#99F7FF',
                        glass: 'rgba(255, 255, 255, 0.05)',
                        blood: '#8a0303',
                    },
                    letterSpacing: {
                        widest: '.25em',
                    }
                }
            }
        }
    </script>
 
    <style>
        /* --- Core & Reset --- */
        html.lenis { height: auto; }
        .lenis.lenis-smooth { scroll-behavior: auto; }
        .lenis.lenis-smooth [data-lenis-prevent] { overscroll-behavior: contain; }
        .lenis.lenis-stopped { overflow: hidden; }
 
        body {
            background: #020205; 
            color: #EAEAEA;
            cursor: none; /* Custom Cursor only */
            overflow-x: hidden;
            margin: 0;
            padding: 0;
            transition: background-color 0.05s;
        }
        
        /* ÊÅêÊÄñ„É¢„Éº„Éâ: ÊîªÊíÉÁöÑ„Å™„Éá„Ç∏„Çø„É´„Çπ„Éà„É≠„Éú */
        body.terror-mode {
            background: #000000;
            animation: razor-strobe 0.08s infinite steps(2); 
            height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        
        @keyframes razor-strobe {
            0% { background-color: #000000; filter: invert(0); }
            30% { background-color: #1a0000; filter: invert(0); }
            50% { background-color: #000000; filter: invert(0); }
            55% { background-color: #ffff00; filter: invert(1); }
            60% { background-color: #000000; filter: invert(0); }
            90% { background-color: #330000; filter: invert(0); }
            100% { background-color: #000000; filter: invert(0); }
        }
 
        /* --- Terror Mode UI Control --- */
        body.terror-mode nav,
        body.terror-mode main,
        body.terror-mode .chat-widget,
        body.terror-mode .sound-visualizer,
        body.terror-mode #sound-toggle, /* Toggle also hides in terror mode */
        body.terror-mode #depth-hud,
        body.terror-mode #cursor-hint {
            opacity: 0;
            pointer-events: none;
            visibility: hidden; 
            transition: opacity 0.05s ease-out;
        }
 
        /* --- Vignette & Atmosphere --- */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 50; 
            /* „Éï„Ç£„É´„Çø„Éº„ÇíÂ§ßÂπÖ„Å´ËñÑ„Åè„Åó„Å¶„ÄÅÁîüÁâ©„ÇíË¶ã„Åà„ÇÑ„Åô„ÅèË™øÊï¥ */
            background: radial-gradient(circle at center, transparent 50%, rgba(0,0,0,0.1) 100%);
            transition: all 1s;
        }
        
        body.terror-mode #vignette {
            background: radial-gradient(circle at center, transparent 15%, rgba(0,0,0,0.9) 60%, #000000 95%);
            box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.2);
            mix-blend-mode: multiply;
        }
        
        /* Ëµ∞ÊüªÁ∑ö„Éé„Ç§„Ç∫ */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 51;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            background-size: 100% 100%;
            opacity: 0;
            transition: opacity 0.1s;
        }
        body.terror-mode #scanlines {
            opacity: 0.6;
            animation: noise-twitch 0.05s infinite;
        }
 
        /* Chromatic Aberration for Charge Effect */
        #rgb-split-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 40;
            mix-blend-mode: screen;
            display: none;
            opacity: 0;
        }
        
        @keyframes noise-twitch {
            0% { transform: translate(0, 0); }
            50% { transform: translate(1px, -1px); }
            100% { transform: translate(-1px, 1px); }
        }
 
        /* --- Custom Cursor --- */
        #cursor-core {
            position: fixed;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            mix-blend-mode: overlay;
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8);
            transition: background 0.3s;
        }
        
        #cursor-ring {
            position: fixed;
            top: 0;
            left: 0;
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 153, 200, 0.4);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            transition: width 0.4s, height 0.4s, border-color 0.4s, background 0.4s;
        }
 
        body.hovering #cursor-ring {
            width: 80px;
            height: 80px;
            background: rgba(255, 153, 200, 0.1);
            border-color: #FF99C8;
            backdrop-filter: blur(2px);
        }
 
        /* Circular Hint Text */
        #cursor-hint {
            position: fixed;
            top: 0; left: 0;
            width: 140px; height: 140px;
            pointer-events: none;
            z-index: 9998;
            transform: translate(-50%, -50%);
            opacity: 0; /* Default hidden, appears on hover or logic */
            transition: opacity 0.5s;
            animation: spin-slow 10s linear infinite;
        }
        #cursor-hint path {
            fill: transparent;
        }
        #cursor-hint text {
            fill: rgba(153, 247, 255, 0.6);
            font-family: 'Share Tech Mono', monospace;
            font-size: 10px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
 
        @keyframes spin-slow {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
 
        /* Charge Indicator */
        #cursor-charge {
            position: fixed;
            top: 0;
            left: 0;
            width: 120px;
            height: 120px;
            pointer-events: none;
            z-index: 9998;
            transform: translate(-50%, -50%) rotate(-90deg);
            opacity: 0;
            transition: opacity 0.1s;
        }
        #cursor-charge circle {
            fill: none;
            stroke: #ff0000;
            stroke-width: 8;
            stroke-linecap: round;
            stroke-dasharray: 283; 
            stroke-dashoffset: 283;
            filter: drop-shadow(0 0 8px #ff0000) drop-shadow(0 0 15px #8a0303);
            transition: stroke-dashoffset 0.1s linear, stroke 0.1s;
        }
        #cursor-charge.shaking {
            animation: charge-vibrate 0.05s infinite;
        }
        @keyframes charge-vibrate {
            0% { transform: translate(-50%, -50%) rotate(-90deg) translate(2px, 2px); }
            25% { transform: translate(-50%, -50%) rotate(-90deg) translate(-2px, -2px); }
            50% { transform: translate(-50%, -50%) rotate(-90deg) translate(-2px, 2px); }
            75% { transform: translate(-50%, -50%) rotate(-90deg) translate(2px, -2px); }
            100% { transform: translate(-50%, -50%) rotate(-90deg) translate(0, 0); }
        }
 
        /* --- WARNING Overlay (Instant & Persistent) --- */
        #warning-container {
            position: fixed;
            inset: 0;
            z-index: 2147483647; 
            pointer-events: none;
            display: none;
            flex-direction: column; 
            justify-content: flex-end; 
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            padding: 2vw;
            padding-bottom: 5vh; 
        }
        
        #warning-container.active {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
 
        .warning-text {
            font-family: 'Syne', sans-serif;
            font-size: min(13vw, 15vh);
            line-height: 0.9;
            font-weight: 900;
            color: #ff0000; 
            -webkit-text-stroke: min(1vw, 6px) #000000;
            paint-order: stroke fill;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            text-align: center;
            width: auto;
            max-width: 95vw;
            white-space: nowrap; 
            overflow: visible;
            background: #000000;
            padding: 10px 20px;
            border-top: 10px solid #ffff00;
            border-bottom: 10px solid #ffff00;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            animation: danger-max 0.12s infinite steps(2);
        }
        
        .warning-text::before,
        .warning-text::after {
            content: "WARNING";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
            mix-blend-mode: exclusion;
            z-index: -1;
        }
        
        .warning-text::before {
            color: #ffff00;
            -webkit-text-stroke: 0;
            animation: glitch-yellow 0.08s infinite reverse;
        }
        
        .warning-text::after {
            color: #00ffff;
            -webkit-text-stroke: 4px #000000;
            animation: glitch-black 0.08s infinite;
        }
 
        @keyframes danger-max {
            0% { color: #ff0000; border-color: #ffff00; transform: scale(1) translate(0, 0); }
            25% { color: #ffff00; background: #2a0000; border-color: #ff0000; transform: scale(1.05) translate(-2px, 2px) skewX(5deg); }
            50% { color: #000000; background: #ff0000; border-color: #000000; -webkit-text-stroke: 0; transform: scale(1.02) translate(2px, -2px) skewX(-5deg); }
            75% { color: #ff0000; transform: scale(1.1) translate(0, 5px); }
            100% { color: #ff0000; background: #000000; transform: scale(1) translate(0, 0); }
        }
        
        @keyframes glitch-yellow {
            0% { transform: translate(0, 0); clip-path: inset(0 0 0 0); opacity: 0; }
            20% { transform: translate(-15px, 5px); clip-path: inset(10% 0 60% 0); opacity: 1; }
            40% { transform: translate(15px, -10px); clip-path: inset(50% 0 10% 0); opacity: 0.5; }
            60% { transform: translate(-5px, 15px); clip-path: inset(0 0 80% 0); opacity: 1; }
            80% { transform: translate(10px, 0px); clip-path: inset(20% 0 20% 0); opacity: 0.8; }
            100% { transform: translate(0, 0); opacity: 0; }
        }
        
        @keyframes glitch-black {
            0% { transform: translate(0, 0); clip-path: inset(0 0 0 0); }
            20% { transform: translate(10px, -5px); clip-path: inset(80% 0 0 0); }
            40% { transform: translate(-10px, 5px); clip-path: inset(0 0 80% 0); }
            60% { transform: translate(5px, 10px); clip-path: inset(40% 0 40% 0); }
            80% { transform: translate(-5px, -10px); clip-path: inset(10% 0 60% 0); }
            100% { transform: translate(0, 0); clip-path: inset(0 0 0 0); }
        }
 
        /* --- Background Canvas --- */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            transition: filter 0.1s;
        }
        
        body.terror-mode #canvas-container {
            filter: grayscale(0.5) contrast(1.8) brightness(1.3) sepia(0.2); 
        }
 
        /* --- Chat & UI --- */
        .chat-widget { position: fixed; bottom: 30px; right: 30px; z-index: 9000; display: flex; flex-direction: column; align-items: flex-end; }
        .chat-toggle { width: 80px; height: 80px; border-radius: 50%; background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(5px); cursor: pointer; display: flex; justify-content: center; align-items: center; transition: transform 0.3s ease; transform-style: preserve-3d; }
        .chat-window { width: 320px; height: 450px; background: rgba(5, 5, 16, 0.85); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px; margin-bottom: 20px; display: flex; flex-direction: column; overflow: hidden; transform-origin: bottom right; transform: scale(0); opacity: 0; transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1); }
        .chat-window.active { transform: scale(1); opacity: 1; }
        .chat-header { padding: 15px; background: rgba(255, 255, 255, 0.05); border-bottom: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: space-between; align-items: center; }
        .chat-messages { flex: 1; padding: 15px; overflow-y: auto; font-family: "Zen Maru Gothic", sans-serif; font-size: 14px; display: flex; flex-direction: column; gap: 12px; }
        .message { max-width: 80%; padding: 10px 14px; border-radius: 12px; line-height: 1.5; word-wrap: break-word; }
        .message.bot { align-self: flex-start; background: rgba(76, 201, 240, 0.2); border-top-left-radius: 2px; color: #EAEAEA; }
        .message.user { align-self: flex-end; background: rgba(255, 153, 200, 0.2); border-bottom-right-radius: 2px; color: #fff; }
        .chat-input-area { padding: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 10px; }
        .chat-input { flex: 1; background: rgba(255, 255, 255, 0.05); border: none; border-radius: 20px; padding: 8px 15px; color: white; font-family: "Zen Maru Gothic", sans-serif; outline: none; }
        .chat-send { background: #4CC9F0; color: #050510; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s; }
        .jelly-3d { position: relative; width: 50px; height: 50px; transform-style: preserve-3d; transition: transform 0.1s ease-out; }
        .jelly-head { position: absolute; top: 0; left: 5px; width: 40px; height: 30px; background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9), rgba(153, 247, 255, 0.8) 40%, rgba(76, 201, 240, 0.4)); border-radius: 50% 50% 40% 40%; box-shadow: 0 0 15px rgba(153, 247, 255, 0.6), inset 0 0 10px rgba(255,255,255,0.5); z-index: 2; }
        .jelly-eyes { position: absolute; top: 12px; left: 10px; width: 30px; display: flex; justify-content: space-between; padding: 0 5px; z-index: 3; transform: translateZ(5px); }
        .eye { width: 4px; height: 6px; background: #050510; border-radius: 50%; --eye-x: 0px; --eye-y: 0px; transform: translate(var(--eye-x), var(--eye-y)); animation: blink 4s infinite; }
        .jelly-tentacles { position: absolute; top: 25px; left: 5px; width: 40px; display: flex; justify-content: space-around; z-index: 1; }
        .tentacle { width: 4px; height: 20px; background: rgba(255, 153, 200, 0.6); border-radius: 2px; animation: wiggle 2s ease-in-out infinite; transform-origin: top center; }
        .tentacle:nth-child(2) { animation-delay: 0.2s; height: 25px; }
        .tentacle:nth-child(3) { animation-delay: 0.4s; }
        .glass-card { background: rgba(255, 255, 255, 0.02); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 24px; transition: transform 0.5s ease, background 0.5s ease; }
        
        .submarine-title {
            display: inline-block;
            font-size: 1.4em; 
            font-weight: 900;
            line-height: 0.9;
            background-image: 
                linear-gradient(180deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 15%, rgba(0,0,0,0.1) 45%, rgba(0,0,0,0.5) 50%, rgba(255,255,255,0) 55%, rgba(255,255,255,0.7) 100%),
                radial-gradient(rgba(0, 0, 0, 0.5) 1.5px, transparent 2px),
               repeating-linear-gradient(90deg, transparent 0px, transparent 24px, rgba(0, 0, 0, 0.6) 25px, rgba(255, 255, 255, 0.2) 26px),
                linear-gradient(to bottom, #94a3b8 0%, #475569 30%, #1e293b 50%, #334155 70%, #64748b 100%);
            background-size: 100% 250%, 6px 6px, 26px 100%, 100% 100%;
            background-position: 50% 0%, 0 0, 0 0, 0 0;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-stroke: 1.5px rgba(226, 232, 240, 0.5);
            animation: metal-shine 8s ease-in-out infinite alternate, deep-pressure 12s cubic-bezier(0.4, 0, 0.2, 1) infinite alternate;
        }
 
        @keyframes metal-shine {
            0% { background-position: 50% 0%, 0 0, 0 0, 0 0; }
            100% { background-position: 50% 100%, 0 0, 0 0, 0 0; }
        }
 
        @keyframes deep-pressure {
            0% { filter: brightness(1.3) contrast(1.1) drop-shadow(0 0 15px rgba(200, 240, 255, 0.6)); transform: scale(1); }
            40% { filter: brightness(0.8) contrast(1.2) drop-shadow(0 0 5px rgba(100, 200, 255, 0.3)); }
            100% { filter: brightness(0.3) contrast(1.5) drop-shadow(0 0 0px rgba(0,0,0,1)); transform: scale(0.98); }
        }
        
        .digital-flicker {
            background: linear-gradient(90deg, #ff00cc 0%, #3333ff 14%, #00ccff 28%, #00ff00 42%, #ffff00 57%, #ff9900 71%, #ff0000 85%, #ff00cc 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: aurora-flow 4s linear infinite, flicker-15s-rainbow 15s infinite linear;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6));
        }
 
        @keyframes flicker-15s-rainbow {
            0%, 70% { opacity: 1; filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6)); }
            70.1% { opacity: 0.3; } 70.3% { opacity: 0.8; filter: none; } 70.6% { opacity: 0.1; } 71% { opacity: 0.6; } 72% { opacity: 0.1; }
            73% { opacity: 0.9; filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.4)); } 74% { opacity: 0.2; }
            75%, 85% { opacity: 0; filter: none; }
            85.1% { opacity: 0.5; } 85.3% { opacity: 0; } 86% { opacity: 0.8; filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.8)); } 86.2% { opacity: 0; }
            90% { opacity: 1; filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 20px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 40px rgba(255, 255, 255, 0.4)); }
            92% { opacity: 0.9; } 100% { opacity: 1; filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6)); }
        }
        
        @keyframes aurora-flow {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        .variable-font-hero span {
            display: inline-block;
            transition: font-weight 0.1s linear, letter-spacing 0.2s ease;
        }
        
        /* New Distortion Classes */
        .distortion-target {
            will-change: filter;
        }
    </style>
</head>
<body class="selection:bg-kawaii_p selection:text-void">
 
    <!-- Flash Overlay -->
    <div id="flash-overlay"></div>
 
    <!-- Scanlines -->
    <div id="scanlines"></div>
    
    <!-- RGB Split / Distortion Layer for Charge -->
    <div id="rgb-split-layer"></div>
 
    <!-- Cursor System -->
    <div id="cursor-core"></div>
    <div id="cursor-ring"></div>
    
    <!-- Circular Hint for Right Click -->
    <svg id="cursor-hint" viewBox="0 0 100 100">
        <path id="circlePath" d="M 50, 50 m -40, 0 a 40,40 0 1,1 80,0 a 40,40 0 1,1 -80,0" />
        <text>
            <textPath href="#circlePath" startOffset="0%">
                HOLD TO DIVE DEEP ‚Ä¢ DANGER ‚Ä¢ DANGER ‚Ä¢ DO NOT HOLD ‚Ä¢
            </textPath>
        </text>
    </svg>
    
    <!-- Charge Indicator -->
    <svg id="cursor-charge" viewBox="0 0 100 100">
        <circle cx="50" cy="50" r="45"></circle>
    </svg>
 
    <!-- Background Art -->
    <div id="canvas-container"></div>
    <!-- Vignette Effect -->
    <div id="vignette"></div>
    
    <!-- Foreground Canvas for Garden Eels (New Layer: ÊúÄÂâçÈù¢) -->
    <div id="foreground-canvas" class="fixed inset-0 z-[60] pointer-events-none"></div>

    <!-- Warning Overlay -->
    <div id="warning-container">
        <div class="warning-text">WARNING</div>
    </div>
 
    <!-- Loader -->
    <div class="loader fixed inset-0 z-[100] flex flex-col items-center justify-center bg-void pointer-events-none transition-opacity duration-1000">
        <div class="font-display font-bold text-6xl tracking-tighter text-kawaii_c animate-pulse">
            CONNECTING...
        </div>
        <div class="font-cute text-kawaii_p text-sm tracking-widest mt-4">
            Summoning Digital Spirits ‚ú®
        </div>
    </div>
 
    <!-- UI Overlay -->
    <nav class="fixed top-0 w-full p-8 flex justify-between items-start z-50 mix-blend-screen text-white pointer-events-none">
        <div class="pointer-events-auto cursor-pointer group">
            <div class="font-display font-bold text-2xl tracking-tighter group-hover:text-kawaii_c transition-colors flex items-center gap-3">
               DEEP DIGITAL
               <div class="w-5 h-3.5 bg-white/90 flex items-center justify-center shadow-[0_0_5px_rgba(255,255,255,0.5)]">
                    <div class="w-2 h-2 bg-[#bc002d] rounded-full"></div>
               </div>
           </div>
            <div class="text-[10px] font-serif opacity-80 tracking-[0.3em] text-kawaii_p">DEEP SEA LAB</div>
        </div>
        <div class="flex flex-col items-end gap-2 font-mono text-xs pointer-events-auto">
            <a href="#works" class="hover:text-kawaii_c transition-colors link-hover">‚ú¶ production</a>
            <a href="https://www.youtube.com/" target="_blank" class="hover:text-kawaii_p transition-colors link-hover">‚ú¶ DIVE LOGÔºàYoutubeÔºâ</a>
            <a href="#about" class="hover:text-biolum transition-colors link-hover">‚ú¶ CREATURES</a>
            <a href="#contact" class="hover:text-kawaii_c transition-colors link-hover">‚ú¶ CONTACT</a>
        </div>
    </nav>
    
    <!-- Depth HUD -->
    <div id="depth-hud" class="fixed right-6 md:right-8 top-1/2 -translate-y-1/2 z-[60] font-mono text-[10px] flex flex-col items-end gap-2 pointer-events-none mix-blend-screen transition-opacity duration-500 hidden md:flex">
        <div class="text-kawaii_c/60 tracking-widest font-serif">LOC: MARIANA TRENCH</div>
        <div id="depth-counter" class="text-4xl font-display font-bold text-white tracking-tighter leading-none">
            0<span class="text-xs ml-1 font-mono">m</span>
        </div>
        <div id="depth-zone" class="text-kawaii_p tracking-[0.3em] uppercase opacity-80 font-serif">Sunlight Zone</div>
        <div class="w-[2px] h-32 bg-white/10 relative mt-4 overflow-hidden rounded-full">
            <div id="depth-bar" class="absolute top-0 left-0 w-full bg-kawaii_c origin-top scale-y-0 h-full"></div>
        </div>
    </div>
 
    <!-- Chat Widget -->
    <div class="chat-widget">
        <div class="chat-window" id="chat-window">
            <div class="chat-header">
                <div class="flex items-center gap-2">
                    <span class="w-2 h-2 rounded-full bg-kawaii_c animate-pulse"></span>
                    <span class="font-cute text-sm tracking-widest">NEON JELLY üîÆ</span>
                </div>
                <button id="chat-close" class="text-xs hover:text-kawaii_p">‚úï</button>
            </div>
            <div class="chat-messages" id="chat-messages">
                <div class="message bot">
                    „Åì„Çì„Å´„Å°„ÅØÔºÅ„Éá„Ç∏„Çø„É´„ÇØ„É©„Ç≤„ÅÆ„Åä„Éº„Å°„ÇÉ„Çì„Å†„Çà (‚óï‚Äø‚óï) <br>
                    ‰ªäÊó•„ÅÆÊ∞óÂàÜ„ÅØ‰ΩïËâ≤ÔºüÂ•Ω„Åç„Å™Ëâ≤„ÇíÊïô„Åà„Å¶„Å≠ÔºÅ‚ú®
                </div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" class="chat-input" placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ..." autocomplete="off">
                <button id="chat-send" class="chat-send">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 2L11 13M22 2L15 22L11 13M11 13L2 9L22 2"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- 3D Jellyfish Toggle Button -->
        <div class="chat-toggle link-hover" id="chat-toggle">
            <div class="jelly-3d" id="jelly-3d">
                <div class="jelly-head">
                    <div class="jelly-eyes">
                        <div class="eye"></div>
                        <div class="eye"></div>
                    </div>
                </div>
                <div class="jelly-tentacles">
                    <div class="tentacle"></div>
                    <div class="tentacle"></div>
                    <div class="tentacle"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Sound Toggle -->
    <button id="sound-toggle" class="fixed bottom-10 left-10 z-[60] w-10 h-10 rounded-full bg-glass border border-white/10 flex items-center justify-center text-white hover:bg-white/10 transition-colors cursor-pointer group">
        <!-- Speaker Icon (On) -->
        <svg id="icon-sound-on" class="w-5 h-5 group-hover:text-kawaii_c transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
        </svg>
        <!-- Speaker Icon (Off) -->
        <svg id="icon-sound-off" class="w-5 h-5 hidden group-hover:text-kawaii_p transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
        </svg>
    </button>
 
    <!-- Sound Visualizer -->
    <div class="sound-visualizer fixed bottom-10 left-24 z-50 flex gap-1 h-8 items-end mix-blend-screen pointer-events-none opacity-50">
        <div class="w-1.5 rounded-full bg-kawaii_p animate-[bounce_1s_infinite] h-4"></div>
        <div class="w-1.5 rounded-full bg-kawaii_c animate-[bounce_1.2s_infinite] h-8"></div>
        <div class="w-1.5 rounded-full bg-kawaii_p animate-[bounce_0.8s_infinite] h-6"></div>
        <div class="w-1.5 rounded-full bg-kawaii_c animate-[bounce_1.5s_infinite] h-3"></div>
    </div>
 
    <main>
        <!-- Content Sections -->
        <section class="h-screen w-full flex items-center justify-center relative perspective-1000">
            <div class="relative z-10 text-center">
                <h1 class="font-display font-black text-[13vw] text-white leading-none tracking-tighter">
                    <div class="overflow-hidden distortion-target"><span class="block reveal-hero translate-y-full submarine-title">DEEP</span></div>
                    <div class="overflow-hidden distortion-target"><span class="block reveal-hero translate-y-full digital-flicker variable-font-hero">DIGITAL</span></div>
                </h1>
                <p class="mt-8 font-serif text-sm md:text-lg tracking-[0.2em] text-white/80 reveal-hero-sub opacity-0">Ask the jelly, color the sea.</p>
            </div>
            <div class="absolute bottom-10 left-1/2 -translate-x-1/2 flex flex-col items-center gap-3 text-center w-full pointer-events-none">
                <div class="text-kawaii_p/60 font-mono text-xs animate-bounce">SCROLL TO DIVE</div>
                <div class="text-white/30 font-tech text-[10px] tracking-[0.3em] uppercase opacity-70">
                    AUDIO PRESSURE ADAPTS TO DEPTH
                </div>
            </div>
        </section>
 
        <!-- Dummy Content -->
        <section class="py-40 px-6 md:px-20 relative z-10">
            <div class="max-w-7xl mx-auto">
                <p class="font-cute text-3xl md:text-6xl font-bold leading-tight text-white/90 fluid-text-block">
                    „ÅÇ„Å™„Åü„ÅÆ <span class="text-kawaii_p glow-effect">Ë®ÄËëâ</span>„Åå„ÄÅ<br>Ê∑±Êµ∑„ÅÆËâ≤„ÇíÂ§â„Åà„Çã„ÄÇ<br>Âè≥‰∏ã„ÉÅ„É£„ÉÉ„Éà„Éú„Çø„É≥„Åß„ÄÅ<br>
                    <span class="outline-text link-hover cursor-pointer italic text-kawaii_c">„Éá„Ç∏„Çø„É´„ÇØ„É©„Ç≤</span>„Å´Ë©±„Åó„Åã„Åë„Å¶„Åø„Å¶„ÄÇ<br>
                    <span class="text-sm opacity-60 block mt-8 tracking-widest leading-relaxed">
                        Ê∑±Êµ∑„Å´„ÅØÁµ∂ÂØæ„Å´Ëµ∑„Åì„Åó„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑ„É¢„Éé„ÇÇÁú†„Å£„Å¶„ÅÑ„Åæ„Åô‚ö†Ô∏è<br>
                        „Ç´„Éº„ÇΩ„É´„ÅÆÂë®„Çä„ÅÆË≠¶Âëä„Å´Âæì„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<br>
                        <span class="text-kawaii_p">Âè≥„ÇØ„É™„ÉÉ„ÇØÔºà„É¢„Éê„Ç§„É´„ÅØÁîªÈù¢Ôºâ„ÇíÈï∑Êäº„Åó„Åó„Å¶„ÅØ„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</span>
                    </span>
                </p>
            </div>
        </section>
        
        <div class="h-[400vh] relative" id="works-wrapper">
            <div class="sticky top-0 h-screen overflow-hidden flex items-center bg-void/5 backdrop-blur-sm border-y border-white/5">
                <div class="horizontal-scroll-container pl-20 flex gap-20 items-center" id="works-container">
                    <div class="w-[40vw] flex-shrink-0">
                        <h2 class="font-display text-[8vw] font-bold outline-text opacity-50 text-kawaii_c variable-section-title">Ê∑±Êµ∑„ÅÆ‰∏ñÁïå</h2>
                        <p class="font-serif text-sm tracking-widest text-kawaii_p">POWERED BY„ÇÇ„Çä„Åè„Çç„Éº</p>
                    </div>
                    <div class="w-[60vw] md:w-[40vw] aspect-[3/4] md:aspect-video flex-shrink-0 glass-card relative group overflow-hidden link-hover cursor-none">
                        <div class="absolute inset-0 flex items-center justify-center">
                            <div class="text-[10rem] text-kawaii_p animate-[spin_10s_linear_infinite] opacity-20">‚ú∫</div>
                        </div>
                        <div class="absolute bottom-0 left-0 p-8 w-full z-10">
                            <div class="text-xs font-mono text-kawaii_p mb-2">02 / BRANDING</div>
                            <h3 class="font-display text-4xl font-bold">STAR DUST</h3>
                        </div>
                    </div>
                </div>
            </div>
        </div>
 
        <!-- YouTube Section -->
        <section id="articles" class="py-32 px-6 md:px-20 relative z-10 bg-void/30 backdrop-blur-md border-t border-white/5">
            <div class="max-w-7xl mx-auto">
                <div class="flex flex-col md:flex-row justify-between items-end mb-16 gap-6">
                    <div>
                        <h2 class="font-display text-4xl md:text-6xl font-bold text-white mb-2 variable-section-title">
                            <span class="text-kawaii_c">DIVE</span> LOGS
                        </h2>
                        <p class="font-serif text-sm tracking-widest text-kawaii_p">ÊúÄÊñ∞„ÅÆÊ∑±Êµ∑Êé¢ÊüªË®òÈå≤</p>
                    </div>
                    <a href="https://www.youtube.com/" target="_blank" class="group flex items-center gap-2 text-sm font-mono text-white/60 hover:text-kawaii_c transition-colors link-hover">
                        <span>VIEW ALL ARCHIVES</span>
                        <svg class="w-4 h-4 transform group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                    </a>
                </div>
 
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                    <!-- Video Card 1 -->
                    <article class="glass-card p-4 group hover:bg-white/5 transition-all duration-500 hover:-translate-y-2">
                        <div class="aspect-video w-full bg-black/50 relative overflow-hidden rounded-xl mb-6 group-hover:shadow-[0_0_30px_rgba(76,201,240,0.3)] transition-shadow">
                            <!-- Placeholder -->
                            <div class="w-full h-full absolute inset-0 bg-void flex items-center justify-center text-white/20">VIDEO 01</div>
                            <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none"></div>
                        </div>
                        <div class="px-2">
                            <div class="flex items-center gap-2 mb-3">
                                <span class="px-2 py-1 rounded text-[10px] font-mono bg-kawaii_p/20 text-kawaii_p border border-kawaii_p/30">NEW</span>
                                <span class="text-xs font-mono text-white/40">2024.03.15</span>
                            </div>
                            <h3 class="font-cute text-lg font-bold text-white mb-2 leading-snug group-hover:text-kawaii_c transition-colors">
                                Ê∑±Êµ∑1000m„ÅÆÊú™Áü•„Å™„ÇãÁîüÁâ©„Å®„ÅÆÈÅ≠ÈÅá
                            </h3>
                            <p class="text-sm text-white/60 line-clamp-2">
                                ÊºÜÈªí„ÅÆÈóá„ÅÆ‰∏≠„ÅßÂÖâ„ÇãË¨é„ÅÆÁîüÂëΩ‰Ωì„ÇíÊçâ„Åà„ÅüË≤¥Èáç„Å™Êò†ÂÉè„ÄÇÊ∑±Êµ∑„ÅÆÁ•ûÁßò„Å´Ëø´„Çã„Éâ„Ç≠„É•„É°„É≥„Çø„É™„Éº„ÄÇ
                            </p>
                        </div>
                    </article>
 
                    <!-- Video Card 2 -->
                    <article class="glass-card p-4 group hover:bg-white/5 transition-all duration-500 hover:-translate-y-2">
                        <div class="aspect-video w-full bg-black/50 relative overflow-hidden rounded-xl mb-6 group-hover:shadow-[0_0_30px_rgba(255,153,200,0.3)] transition-shadow">
                            <div class="w-full h-full absolute inset-0 bg-void flex items-center justify-center text-white/20">VIDEO 02</div>
                        </div>
                        <div class="px-2">
                            <div class="flex items-center gap-2 mb-3">
                                <span class="px-2 py-1 rounded text-[10px] font-mono bg-biolum/20 text-biolum border border-biolum/30">VLOG</span>
                                <span class="text-xs font-mono text-white/40">2024.03.01</span>
                            </div>
                            <h3 class="font-cute text-lg font-bold text-white mb-2 leading-snug group-hover:text-kawaii_p transition-colors">
                                „Éá„Ç∏„Çø„É´Ê∞¥ÊóèÈ§®„ÅÆË£èÂÅ¥„ÉÑ„Ç¢„Éº
                            </h3>
                            <p class="text-sm text-white/60 line-clamp-2">
                                PRISM FLUX„ÅÆÂà∂‰ΩúÁßòË©±„Å®„ÄÅ„ÇØ„É™„Ç®„Ç§„ÉÜ„Ç£„Éñ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„ÅÆÊäÄË°ìËß£Ë™¨„ÄÇ
                            </p>
                        </div>
                    </article>
 
                    <!-- Video Card 3 -->
                    <article class="glass-card p-4 group hover:bg-white/5 transition-all duration-500 hover:-translate-y-2">
                        <div class="aspect-video w-full bg-black/50 relative overflow-hidden rounded-xl mb-6 group-hover:shadow-[0_0_30px_rgba(153,247,255,0.3)] transition-shadow">
                            <div class="w-full h-full absolute inset-0 bg-void flex items-center justify-center text-white/20">VIDEO 03</div>
                        </div>
                        <div class="px-2">
                            <div class="flex items-center gap-2 mb-3">
                                <span class="px-2 py-1 rounded text-[10px] font-mono bg-white/10 text-white/80 border border-white/20">ASMR</span>
                                <span class="text-xs font-mono text-white/40">2024.02.14</span>
                            </div>
                            <h3 class="font-cute text-lg font-bold text-white mb-2 leading-snug group-hover:text-kawaii_c transition-colors">
                                ËÅ¥„ÅèÊ∑±Êµ∑ - Deep Sea Ambience
                            </h3>
                            <p class="text-sm text-white/60 line-clamp-2">
                                ‰ΩúÊ•≠Áî®BGM„ÄÇÊ∞¥Âúß„ÇíÊÑü„Åò„ÇãÈáç‰ΩéÈü≥„Å®„ÄÅÊ≥°„ÅÆÈü≥„Å´„Çà„Çã„É™„É©„ÇØ„Çº„Éº„Ç∑„Éß„É≥„ÄÇ
                            </p>
                        </div>
                    </article>
                </div>
            </div>
        </section>
        
        <!-- Footer -->
        <footer id="contact" class="pt-20 pb-40 px-6 md:px-20 border-t border-white/10 flex flex-col gap-8 items-start bg-void relative z-10">
            <div><h2 class="font-display text-3xl font-bold text-kawaii_c">DEEP DIGITAL</h2></div>
            
            <!-- SNS Icons -->
            <div class="flex gap-6">
                <a href="#" target="_blank" class="text-white/60 hover:text-kawaii_p transition-colors transform hover:scale-110 duration-300">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                    </svg>
                </a>
                <a href="#" target="_blank" class="text-white/60 hover:text-kawaii_p transition-colors transform hover:scale-110 duration-300">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                         <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </a>
                <a href="#" target="_blank" class="text-white/60 hover:text-kawaii_p transition-colors transform hover:scale-110 duration-300">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                        <path fill-rule="evenodd" d="M12.315 2c2.43 0 2.784.013 3.808.06 1.064.049 1.791.218 2.427.465a4.902 4.902 0 0 1 1.772 1.153 4.902 4.902 0 0 1 1.153 1.772c.247.636.416 1.363.465 2.427.048 1.067.06 1.407.06 4.123v.08c0 2.643-.012 2.987-.06 4.043-.049 1.064-.218 1.791-.465 2.427a4.902 4.902 0 0 1-1.153 1.772 4.902 4.902 0 0 1-1.772 1.153c-.636.247-1.363.416-2.427.465-1.067.048-1.407.06-4.123.06h-.08c-2.643 0-2.987-.012-4.043-.06-1.064-.049-1.791-.218-2.427-.465a4.902 4.902 0 0 1-1.772-1.153 4.902 4.902 0 0 1-1.153-1.772c-.247-.636-.416-1.363-.465-2.427-.047-1.024-.06-1.379-.06-3.808v-.63c0-2.43.013-2.784.06-3.808.049-1.064.218-1.791.465-2.427a4.902 4.902 0 0 1 1.153-1.772A4.902 4.902 0 0 1 5.451 4.635c.636-.247 1.363-.416 2.427-.465C8.901 2.013 9.256 2 11.685 2h.63zm-.081 1.802h-.468c-2.456 0-2.784.011-3.807.058-.975.045-1.504.207-1.857.344-.467.182-.8.398-1.15.748-.35.35-.566.683-.748 1.15-.137.353-.3.882-.344 1.857-.047 1.023-.058 1.351-.058 3.807v.468c0 2.456.011 2.784.058 3.807.045.975.207 1.504.344 1.857.182.466.399.8.748 1.15.35.35.683.566 1.15.748.353.137.882.3 1.857.344 1.054.048 1.37.058 4.041.058h.08c2.597 0 2.917-.01 3.96-.058.976-.045 1.505-.207 1.858-.344.466-.182.8-.398 1.15-.748.35-.35.566-.683.748-1.15.137-.353.3-.882.344-1.857.048-1.055.058-1.37.058-4.041v-.08c0-2.597-.01-2.917-.058-3.96-.045-.976-.207-1.505-.344-1.858a3.097 3.097 0 0 0-.748-1.15 3.098 3.098 0 0 0-1.15-.748c-.353-.137-.882-.3-1.857-.344-1.023-.047-1.351-.058-3.807-.058zM12 6.865a5.135 5.135 0 1 1 0 10.27 5.135 5.135 0 0 1 0-10.27zm0 1.802a3.333 3.333 0 1 0 0 6.666 3.333 3.333 0 0 0 0-6.666zm5.338-3.205a1.2 1.2 0 1 1 0 2.4 1.2 1.2 0 0 1 0-2.4z" clip-rule="evenodd"/>
                    </svg>
                </a>
            </div>
        </footer>
    </main>
 
    <script>
        // --- 0. Shared State & Config ---
        let isTerrorMode = false;
        let isCharging = false;
        let chargeStartTime = 0;
        const CHARGE_DURATION = 3000;
        window.chargeProgress = 0;
        
        // Èü≥Â£∞Áä∂ÊÖãÁÆ°ÁêÜ„Éï„É©„Ç∞
        let isSoundOn = false;
        
        // --- Audio System Core ---
        let audioCtx;
        let alarmOsc, alarmGain, alarmFilter;
        let heartbeatOsc, heartbeatGain;
        let terrorNodes = []; 
        let ambienceNodes = []; 
        // Ê∑±Â∫¶ÈÄ£ÂãïÁî®„ÅÆ„Éï„Ç£„É´„Çø„Éé„Éº„ÉâÂèÇÁÖß
        let ambienceFilterNode = null;
        // ÂëºÂê∏„Çµ„Ç§„ÇØ„É´„Çø„Ç§„Éû„Éº
        let breathingTimer = null;
        let bioSonarTimer = null;
 
        function ensureAudioContext() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Audio Context init failed:", e);
                }
            }
        }
 
        // --- Helper: Create Noise Buffer ---
        // type: 'white', 'pink', 'brown'
        function createNoiseBuffer(type = 'white', duration = 2.0) {
            if (!audioCtx) return null;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            
            if (type === 'white') {
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
            } else if (type === 'pink') {
                let b0, b1, b2, b3, b4, b5, b6;
                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    data[i] *= 0.11; 
                    b6 = white * 0.115926;
                }
            } else { // brown
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    lastOut = (lastOut + (0.02 * white)) / 1.02;
                    data[i] = lastOut * 3.5;
                    if (data[i] > 1) data[i] = 1;
                    if (data[i] < -1) data[i] = -1;
                }
            }
            return buffer;
        }
 
        // --- Helper: Create Reverb Buffer (Impulse Response) ---
        function createReverbBuffer(duration = 2.0, decay = 2.0) {
            if (!audioCtx) return null;
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const n = i / length;
                // ÊåáÊï∞Ê∏õË°∞„Åï„Åõ„Çã„Éé„Ç§„Ç∫
                const vol = Math.pow(1 - n, decay); 
                left[i] = (Math.random() * 2 - 1) * vol;
                right[i] = (Math.random() * 2 - 1) * vol;
            }
            return impulse;
        }
 
        // --- Sound Toggle Logic ---
        const soundToggle = document.getElementById('sound-toggle');
        const iconOn = document.getElementById('icon-sound-on');
        const iconOff = document.getElementById('icon-sound-off');
 
        function updateSoundIcon(isPlaying) {
            if (isPlaying) {
                iconOn.classList.remove('hidden');
                iconOff.classList.add('hidden');
                soundToggle.classList.add('bg-glass');
                soundToggle.classList.remove('bg-white/20');
            } else {
                iconOn.classList.add('hidden');
                iconOff.classList.remove('hidden');
                soundToggle.classList.add('bg-white/20');
                soundToggle.classList.remove('bg-glass');
            }
        }
 
        soundToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            ensureAudioContext();
            if (!audioCtx) return;
            isSoundOn = !isSoundOn;
 
            if (isSoundOn) {
                audioCtx.resume().then(() => {
                    updateSoundIcon(true);
                    if (!isTerrorMode) {
                        startDeepSeaAmbience();
                    }
                });
            } else {
                audioCtx.suspend().then(() => {
                    updateSoundIcon(false);
                });
            }
        });
 
        // --- 1. Diver Breathing System ---
        // „ÄåÂê∏Ê∞ó(Inhale)„Äç‚Üí„ÄåÈñì(Hold)„Äç‚Üí„ÄåÊéíÊ∞ó(Exhale/Bubbles)„Äç„ÅÆ„Çµ„Ç§„ÇØ„É´
        const DiverBreathing = {
            inhaleBuffer: null,
            
            init() {
                if (!this.inhaleBuffer) this.inhaleBuffer = createNoiseBuffer('pink', 1.5);
            },
 
            playInhale() {
                if (!audioCtx || isTerrorMode || !isSoundOn) return;
                const t = audioCtx.currentTime;
                
                const src = audioCtx.createBufferSource();
                src.buffer = this.inhaleBuffer;
                
                // „É¨„ÇÆ„É•„É¨„Éº„Çø„Éº„ÇíÈÄö„Åó„ÅüÈü≥„Å´„Åô„Çã„Åü„ÇÅ„ÅÆ„Éï„Ç£„É´„Çø
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                // Â§âÊõ¥: 1200Hz -> 600Hz„ÄÇ„Çà„Çä‰Ωé„Åè„ÄÅÂ§™„ÅÑÈü≥„Å´„Åó„Å¶ËÄ≥Èöú„Çä„Å™È´òÂüü„Çí„Ç´„ÉÉ„Éà
                filter.frequency.value = 600;
                filter.Q.value = 1.0;
 
                const gain = audioCtx.createGain();
                // Â§âÊõ¥: Âê∏Ê∞óÈü≥„ÅÆ„Ç≤„Ç§„É≥„Çí„Åï„Çâ„Å´ÂçäÂàÜ„Å´ (0.08 -> 0.04)
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.04, t + 0.2); // Âê∏„ÅÑÂßã„ÇÅ
                gain.gain.linearRampToValueAtTime(0, t + 1.2);   // Âê∏„ÅÑÁµÇ„Çè„Çä
 
                src.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
 
                src.start(t);
                src.stop(t + 1.3);
            },
 
            playExhale() {
                if (!audioCtx || isTerrorMode || !isSoundOn) return;
                
                // „Ç¥„Éú„Ç¥„ÉúÈü≥„ÅÆÈÄ£Êâì„Çí„ÇÑ„ÇÅ„ÄÅÈáç„ÅÑÊéíÊ∞óÈü≥„ÇíÂ∞ëÊï∞È≥¥„Çâ„Åô
                const t = audioCtx.currentTime;
 
                // ÊéíÊ∞óÂàùÊúü„ÅÆË°ùÊíÉÈü≥ÔºàLow kickÁöÑ„Å™Èü≥Ôºâ„Çí„Åï„Çâ„Å´Èáç„Åè„ÄÅ‰Ωé„Åè
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                // 150Hz -> 80Hz
                osc.frequency.setValueAtTime(80, t);
                osc.frequency.exponentialRampToValueAtTime(30, t + 0.4);
                // Èü≥Èáè„ÇÇÊéß„Åà„ÇÅ„Å´ (0.08 -> 0.04)
                g.gain.setValueAtTime(0.04, t);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                osc.connect(g);
                g.connect(audioCtx.destination);
                osc.start(t);
                osc.stop(t + 0.4);
 
                // Èáç„ÅÑ„Éú„Ç≥Èü≥„ÇíÂ∞ë„Åó„Å†„ÅëÊ∑∑„Åú„Çã (5Âõû -> 2-3Âõû)
                const count = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < count; i++) {
                    const delay = i * 0.15 + Math.random() * 0.1;
                    this.createBubble(t + delay);
                }
            },
 
            createBubble(startTime) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
 
                osc.type = 'sine';
                // Âë®Ê≥¢Êï∞„ÇíÂ§ßÂπÖ„Å´‰∏ã„Åí„Å¶„ÄåÈáç„ÅÑÊ≥°„Äç„Å´„Åô„Çã
                // 200~500Hz -> 60~150Hz
                const startFreq = 60 + Math.random() * 90;
                const endFreq = startFreq + 50; 
 
                osc.frequency.setValueAtTime(startFreq, startTime);
                osc.frequency.linearRampToValueAtTime(endFreq, startTime + 0.2);
 
                // „Éï„Ç£„É´„Çø„ÇÇÂº∑„ÅèÈñâ„Åò„Çã
                filter.type = 'lowpass';
                filter.frequency.value = 200; // 600 -> 200
 
                gain.gain.setValueAtTime(0, startTime);
                // Èü≥Èáè„Åï„Çâ„Å´Êéß„Åà„ÇÅ (0.1 -> 0.05)
                gain.gain.linearRampToValueAtTime(0.05, startTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);
 
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
 
                osc.start(startTime);
                osc.stop(startTime + 0.35);
            },
 
            startCycle() {
                if (breathingTimer) clearTimeout(breathingTimer);
                if (!audioCtx || isTerrorMode || !isSoundOn) return;
                
                // 1. Âê∏Ê∞ó
                this.playInhale();
 
                // 2. „Éõ„Éº„É´„Éâ (1.5ÁßíÂæå)
                // 3. ÊéíÊ∞ó
                const holdDuration = 1500 + Math.random() * 1000;
                
                setTimeout(() => {
                    this.playExhale();
                }, holdDuration);
 
                // Ê¨°„ÅÆ„Çµ„Ç§„ÇØ„É´‰∫àÁ¥Ñ (ÈñìÈöî„Çí„Åï„Çâ„Å´Â∫É„Åí„Å¶„ÄåÈùôÂØÇ„Äç„Çí‰Ωú„Çã 8-12s -> 10-15s)
                const nextCycle = 10000 + Math.random() * 5000;
                breathingTimer = setTimeout(() => {
                    this.startCycle();
                }, nextCycle);
            },
 
            stop() {
                if (breathingTimer) clearTimeout(breathingTimer);
            }
        };
 
        // --- 2. Depth Sensitive Filter ---
        function updateAudioDepth() {
            if (!ambienceFilterNode || !audioCtx || isTerrorMode) return;
            
            // „Çπ„ÇØ„É≠„Éº„É´Ê∑±Â∫¶ (0.0 - 1.0)
            const depth = window.globalScrollRatio || 0;
            
            // Â§âÊõ¥: ÈñæÂÄ§„Çí2500m(0.23)„Åã„Çâ1200m(Á¥Ñ0.11)„Å∏Â§âÊõ¥
            // „Åì„Çå„Å´„Çà„Çä„ÄÅÊØîËºÉÁöÑÊµÖ„ÅÑÊÆµÈöé„Åã„ÇâÈü≥„ÅÆÂ§âÂåñÔºàÈñâÂ°ûÊÑü„ÉªÊ∞¥ÂúßÊÑüÔºâ„Å´Ê∞ó„Å•„Åç„ÇÑ„Åô„Åè„Å™„Çã
            const threshold = 0.11;
            
            // Âë®Ê≥¢Êï∞Ë®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ
            // ÂàùÊúüÁä∂ÊÖã(0m)„Åß„ÇÇ„Åã„Å™„ÇäÁ±†„ÇÇ„Çâ„Åõ„Çã (600Hz)
            // 1200m„Åæ„Åß„ÅØÁ∑©„ÇÑ„Åã„Å´‰Ωé‰∏ã
            // 1200m„ÇíË∂Ö„Åà„Çã„Å®ÊÄ•ÊøÄ„Å´„ÄåÂúß„Äç„Åå„Åã„Åã„Çä„ÄÅ„Åª„ÅºÈáç‰ΩéÈü≥„ÅÆ„Åø(80Hz)„Å´„Å™„Çã
            
            let targetFreq;
            let droneVol;
            
            if (depth < threshold) {
                // 0m - 1200m: 600Hz -> 300Hz
                const ratio = depth / threshold;
                targetFreq = 600 - (ratio * 300);
                // „Éâ„É≠„Éº„É≥Èü≥Èáè„ÅØÊéß„Åà„ÇÅ (0.05 -> 0.1) => Èü≥ÈáèÂçäÊ∏õË™øÊï¥: (0.025 -> 0.05)
                droneVol = 0.025 + (ratio * 0.025);
            } else {
                // 1200m - 10000m: 300Hz -> 80Hz (ÊÄ•ÊøÄ„Å´ÈñâÂ°ûÊÑü)
                const ratio = (depth - threshold) / (1 - threshold);
                // ÊåáÊï∞ÁöÑ„Å´ËêΩ„Å®„Åô„Ç§„É°„Éº„Ç∏„Åß
                targetFreq = 300 - (Math.pow(ratio, 0.5) * 220); 
                // „Éâ„É≠„Éº„É≥Èü≥Èáè„Åå‰∏ä„Åå„Çä„ÄÅÂúßËø´ÊÑü„ÅåÂ¢ó„Åô (0.1 -> 0.25) => Èü≥ÈáèÂçäÊ∏õË™øÊï¥: (0.05 -> 0.125)
                droneVol = 0.05 + (ratio * 0.075);
            }
            
            // ÂÆâÂÖ®Á≠ñ
            if (targetFreq < 50) targetFreq = 50;
            
            // Êªë„Çâ„Åã„Å´Â§âÂåñ„Åï„Åõ„Çã
            ambienceFilterNode.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.5);
 
            // Èáç‰ΩéÈü≥(Drone)„ÅÆÈü≥ÂúßÂà∂Âæ°
            // ambienceNodes[8] is droneGain
            if (ambienceNodes[8]) {
                const droneGainNode = ambienceNodes[8];
                droneGainNode.gain.setTargetAtTime(droneVol, audioCtx.currentTime, 0.5);
            }
        }
 
        // --- 3. Bioacoustics (Sonar Clicks) ---
        function scheduleBioSonar() {
            if (bioSonarTimer) clearTimeout(bioSonarTimer);
            if (!audioCtx || isTerrorMode || !isSoundOn) return;
 
            // 15Áßí„Äú40Áßí„Å´1Âõû
            const nextTime = 15000 + Math.random() * 25000;
            bioSonarTimer = setTimeout(() => {
                playBioSonar();
                scheduleBioSonar();
            }, nextTime);
        }
 
        function playBioSonar() {
            if (!audioCtx || isTerrorMode) return;
            const t = audioCtx.currentTime;
 
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(3000, t); 
            osc.frequency.exponentialRampToValueAtTime(500, t + 0.05); 
 
            // Èü≥Èáè„Çí‰∏ã„Åí„Çã (0.08 -> 0.04)
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.04, t + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
 
            const delay = audioCtx.createDelay();
            delay.delayTime.value = 0.2 + Math.random() * 0.1; 
            
            const delayGain = audioCtx.createGain();
            delayGain.gain.value = 0.1; // Feedback„ÇÇÂçäÂàÜ„Å´ (0.2 -> 0.1)
 
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000; 
 
            osc.connect(gain);
            gain.connect(filter);
            filter.connect(audioCtx.destination);
            
            filter.connect(delay);
            delay.connect(delayGain);
            delayGain.connect(delay); 
            delayGain.connect(audioCtx.destination);
            
            delayGain.gain.setTargetAtTime(0, t + 2.0, 0.5);
 
            osc.start(t);
            osc.stop(t + 0.1);
        }
 
        // --- 4. Deep Sea Ambience (Main) ---
        function startDeepSeaAmbience() {
            if (!audioCtx || !isSoundOn) return; 
            if (ambienceNodes.length > 0) return; 
 
            try {
                const t = audioCtx.currentTime;
                // „Éé„Ç§„Ç∫„Éê„ÉÉ„Éï„Ç°ÁîüÊàê (Brown for low rumble)
                const buffer = createNoiseBuffer('brown', 5.0);
                const noiseSrc = audioCtx.createBufferSource();
                noiseSrc.buffer = buffer;
                noiseSrc.loop = true;
 
                // Ê∑±Â∫¶ÈÄ£ÂãïÁî®„Éï„Ç£„É´„Çø
                ambienceFilterNode = audioCtx.createBiquadFilter();
                ambienceFilterNode.type = 'lowpass';
                // ÂàùÊúüÂÄ§: 600Hz (‰ª•Ââç„ÅÆ2000Hz„Åã„ÇâÂ§ßÂπÖ„ÉÄ„Ç¶„É≥„ÄÅÊúÄÂàù„Åã„ÇâÊ∞¥‰∏≠„ÅÆÈü≥)
                ambienceFilterNode.frequency.value = 600; 
                ambienceFilterNode.Q.value = 0.5;
 
                // Èü≥Èáè
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(0, t);
                // ÂÖ®‰Ωì„Éú„É™„É•„Éº„É†: 0.08 -> 0.04 (Êú¨ÂΩì„Å´„Åã„Åô„Åã)
                noiseGain.gain.linearRampToValueAtTime(0.04, t + 3);
 
                // Êé•Á∂ö
                noiseSrc.connect(ambienceFilterNode);
                ambienceFilterNode.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noiseSrc.start(t);
 
                // --- 2. Sub-bass Drone (The Pressure) ---
                const subOsc1 = audioCtx.createOscillator();
                subOsc1.type = 'sine';
                subOsc1.frequency.value = 40; 
 
                const subOsc2 = audioCtx.createOscillator();
                subOsc2.type = 'triangle'; 
                subOsc2.frequency.value = 43; 
 
                // Drone Volume
                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0;
                // ÂàùÊúüÈü≥Èáè: 0.05 -> 0.025
                // Ê∑±Â∫¶„Å´Âøú„Åò„Å¶ updateAudioDepth „Åß‰∏ä„Åå„Å£„Å¶„ÅÑ„Åè‰ªïÁµÑ„Åø„Å´Â§âÊõ¥
                droneGain.gain.linearRampToValueAtTime(0.025, t + 8); 
 
                // LFO
                const droneLfo = audioCtx.createOscillator();
                droneLfo.type = 'sine';
                droneLfo.frequency.value = 0.1;
                const droneLfoGain = audioCtx.createGain();
                droneLfoGain.gain.value = 0.05; 
                
                // --- Connections ---
                droneLfo.connect(droneLfoGain);
                droneLfoGain.connect(droneGain.gain);
 
                subOsc1.connect(droneGain);
                subOsc2.connect(droneGain);
                droneGain.connect(audioCtx.destination);
 
                // Start Drone
                subOsc1.start();
                subOsc2.start();
                droneLfo.start();
 
                // „Éé„Éº„ÉâÁÆ°ÁêÜ (Index 8 is droneGain)
                ambienceNodes = [
                    noiseSrc, 
                    ambienceFilterNode, 
                    noiseGain, 
                    subOsc1, 
                    subOsc2, 
                    droneLfo, 
                    droneLfoGain, 
                    null, 
                    droneGain 
                ];
 
                // „ÉÄ„Ç§„Éê„ÉºÂëºÂê∏ÈñãÂßã
                DiverBreathing.init();
                DiverBreathing.startCycle();
 
                // „Éê„Ç§„Ç™„Ç¢„Ç≥„Éº„Çπ„ÉÜ„Ç£„ÇØ„ÇπÈñãÂßã
                scheduleBioSonar();
 
            } catch (e) {
                console.error("Deep Sea Ambience Error:", e);
            }
        }
 
        function stopDeepSeaAmbience() {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            
            // Stop timers
            DiverBreathing.stop();
            if (bioSonarTimer) clearTimeout(bioSonarTimer);
 
            // Fade out nodes
            ambienceNodes.forEach(node => {
                if (node && node.gain) {
                    node.gain.cancelScheduledValues(t);
                    node.gain.setTargetAtTime(0, t, 0.5);
                }
                if (node && node.stop) {
                    node.stop(t + 1.0);
                }
            });
            
            setTimeout(() => {
                ambienceNodes.forEach(node => { if(node) node.disconnect(); });
                ambienceNodes = [];
                ambienceFilterNode = null;
            }, 1100);
        }
 
        // --- Heartbeat & Alarm (Existing) ---
        function startAlarm() {
            if (!isSoundOn || !audioCtx) return;
            const time = audioCtx.currentTime;
            if (!alarmOsc) {
                alarmOsc = audioCtx.createOscillator();
                alarmGain = audioCtx.createGain();
                alarmFilter = audioCtx.createBiquadFilter();
                alarmOsc.type = 'sawtooth';
                alarmOsc.frequency.value = 100;
                alarmFilter.type = 'lowpass';
                alarmFilter.frequency.value = 200; 
                alarmOsc.connect(alarmFilter);
                alarmFilter.connect(alarmGain);
               alarmGain.connect(audioCtx.destination);
                alarmGain.gain.value = 0; 
                alarmOsc.start();
            }
            if (!heartbeatOsc) {
                heartbeatOsc = audioCtx.createOscillator();
                heartbeatGain = audioCtx.createGain();
                heartbeatOsc.type = 'sine';
                heartbeatOsc.frequency.value = 50; 
               heartbeatOsc.connect(heartbeatGain);
               heartbeatGain.connect(audioCtx.destination);
                heartbeatGain.gain.value = 0;
                heartbeatOsc.start();
            }
        }
        function updateAlarm(progress) {
            if (!audioCtx || !isSoundOn) return;
            const time = audioCtx.currentTime;
            if(alarmOsc) {
                const targetFreq = 100 + (progress * 1100);
               alarmOsc.frequency.setTargetAtTime(targetFreq, time, 0.1);
                const filterFreq = 200 + (progress * 4800);
               alarmFilter.frequency.setTargetAtTime(filterFreq, time, 0.1);
                const beepSpeed = 4 + (progress * 30);
                const pulse = Math.sin(time * beepSpeed * Math.PI * 2);
                // Alarm Volume: 0.1 -> 0.05
                const vol = pulse > 0 ? (0.05 + progress * 0.075) : 0.0125; 
               alarmGain.gain.setTargetAtTime(vol, time, 0.05);
            }
            if(heartbeatOsc) {
                const beatRate = 1 + (progress * 5); 
                const beatPulse = Math.sin(time * beatRate * Math.PI * 2);
                // Heartbeat Volume: 0.4 -> 0.2
                const beatVol = beatPulse > 0.5 ? 0.2 : 0.0; 
               heartbeatGain.gain.setTargetAtTime(beatVol * (0.5 + progress), time, 0.05);
            }
        }
        function stopAlarm() {
            if (!audioCtx) return;
            const time = audioCtx.currentTime;
            if (alarmOsc) {
                try {
                   alarmGain.gain.setTargetAtTime(0, time, 0.1);
                    setTimeout(() => {
                        if(alarmOsc) { alarmOsc.stop(); alarmOsc.disconnect(); }
                        if(alarmGain) alarmGain.disconnect();
                        if(alarmFilter) alarmFilter.disconnect();
                        alarmOsc = null;
                    }, 200);
                } catch(e) {}
            }
            if (heartbeatOsc) {
                try {
                   heartbeatGain.gain.setTargetAtTime(0, time, 0.1);
                    setTimeout(() => {
                        if(heartbeatOsc) { heartbeatOsc.stop(); heartbeatOsc.disconnect(); }
                        if(heartbeatGain) heartbeatGain.disconnect();
                        heartbeatOsc = null;
                    }, 200);
                } catch(e) {}
            }
        }
 
        // --- 5. Terror BGM (Free Flow & Drone) ---
        function startTerrorSound() {
            if (!isSoundOn) return;
            ensureAudioContext();
            if (!audioCtx) return;
 
            stopTerrorSound(); 
            stopDeepSeaAmbience(); 
 
            const t = audioCtx.currentTime;
 
            // 1. Drone (Base Terror)
            const droneOsc = audioCtx.createOscillator();
            const droneGain = audioCtx.createGain();
            droneOsc.type = 'sawtooth';
            droneOsc.frequency.value = 35;
            droneGain.gain.setValueAtTime(0, t);
            // Terror Drone Volume: 0.25 -> 0.125
            droneGain.gain.linearRampToValueAtTime(0.125, t + 2);
            droneOsc.connect(droneGain);
            droneGain.connect(audioCtx.destination);
            droneOsc.start();
            terrorNodes.push(droneOsc, droneGain);
 
            // 2. Screech (FM)
            const sOsc = audioCtx.createOscillator();
            const sGain = audioCtx.createGain();
            const mOsc = audioCtx.createOscillator();
            const mGain = audioCtx.createGain();
            sOsc.frequency.value = 400;
            mOsc.frequency.value = 5;
            mGain.gain.value = 200;
            mOsc.connect(mGain);
            mGain.connect(sOsc.frequency);
            sOsc.connect(sGain);
            sGain.connect(audioCtx.destination);
            // Screech Volume: 0.025 -> 0.0125
            sGain.gain.value = 0.0125;
            sOsc.start();
            mOsc.start();
            terrorNodes.push(sOsc, sGain, mOsc, mGain);
 
            // 3. Free Flow Noise (Jet Sound - Ê©üÊùêÊïÖÈöú)
            // È´òÂúß„ÅßÁ©∫Ê∞ó„ÅåÊºè„Çå„ÇãÊøÄ„Åó„ÅÑÈü≥
            const flowBuffer = createNoiseBuffer('pink', 2.0);
            const flowSrc = audioCtx.createBufferSource();
            flowSrc.buffer = flowBuffer;
            flowSrc.loop = true;
 
            const flowFilter = audioCtx.createBiquadFilter();
            flowFilter.type = 'highpass';
            flowFilter.frequency.value = 800; // ‰ΩéÂüü„ÇíÂâä„Å£„Å¶„Äå„Ç∑„É•„Éº„ÉÉ„Äç„Å®„ÅÑ„ÅÜÈü≥„Å´„Åô„Çã
            
            const flowGain = audioCtx.createGain();
            flowGain.gain.setValueAtTime(0, t);
            // Terror Flow Volume: 0.4 -> 0.2
            flowGain.gain.exponentialRampToValueAtTime(0.2, t + 0.5);
            
            // ‰∏çË¶èÂâá„Å™Â§âÂãï„ÇíÂä†„Åà„Çã (LFO)
            const flowLFO = audioCtx.createOscillator();
            flowLFO.type = 'sawtooth';
            flowLFO.frequency.value = 15; // ÈÄü„ÅÑÊåØÂãï
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 0.05; // Modulation depth also halved
            
            flowLFO.connect(lfoGain);
            lfoGain.connect(flowGain.gain);
 
            flowSrc.connect(flowFilter);
            flowFilter.connect(flowGain);
            flowGain.connect(audioCtx.destination);
 
            flowSrc.start(t);
            flowLFO.start(t);
            
            terrorNodes.push(flowSrc, flowFilter, flowGain, flowLFO, lfoGain);
        }
 
        function stopTerrorSound() {
            terrorNodes.forEach(node => {
                try {
                    if(node.stop) node.stop();
                    node.disconnect();
                } catch(e) {}
            });
            terrorNodes = [];
        }
        
        // --- Gemini API & Chat Logic ---
        const apiKey = ""; // API Key reset due to Referer blocking. Please use a key without referrer restrictions or use the demo environment.
 
        const chatToggle = document.getElementById('chat-toggle');
        const chatWindow = document.getElementById('chat-window');
        const chatClose = document.getElementById('chat-close');
        const chatInput = document.getElementById('chat-input');
        const chatSend = document.getElementById('chat-send');
        const chatMessages = document.getElementById('chat-messages');
 
        chatToggle.addEventListener('click', () => {
            chatWindow.classList.toggle('active');
            if(chatWindow.classList.contains('active')) chatInput.focus();
        });
        chatClose.addEventListener('click', () => chatWindow.classList.remove('active'));
 
        // --- 3D Jelly Interactive Logic ---
        document.addEventListener('mousemove', (e) => {
            const jelly = document.getElementById('jelly-3d');
            const eyes = document.querySelectorAll('.eye');
            if(!jelly) return;
            const rect = chatToggle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const deltaX = e.clientX - centerX;
            const deltaY = e.clientY - centerY;
            const rotateY = Math.min(Math.max(-deltaX / 15, -60), 60); 
            const rotateX = Math.min(Math.max(-deltaY / 15, -60), 60); 
            jelly.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            const angle = Math.atan2(deltaY, deltaX);
            const maxRadius = 6; 
            const distance = Math.min(Math.hypot(deltaX, deltaY) / 10, maxRadius);
            const eyeX = Math.cos(angle) * distance;
            const eyeY = Math.sin(angle) * distance;
            eyes.forEach(eye => {
                eye.style.setProperty('--eye-x', `${eyeX}px`);
                eye.style.setProperty('--eye-y', `${eyeY}px`);
            });
        });
 
        // Send Message
        const sendMessage = async () => {
            const text = chatInput.value.trim();
            if(!text) return;
            appendMessage('user', text);
            chatInput.value = '';
            chatInput.disabled = true;
            chatSend.disabled = true;
            const loadingId = appendMessage('bot', '<span class="animate-pulse">thinking...</span>');
            
            try {
                const response = await callGemini(text);
                const loadingEl = document.getElementById(loadingId);
                if(loadingEl) loadingEl.remove();
                
                const colorMatch = response.match(/\[COLOR:\s*(#[0-9A-Fa-f]{6})\]/);
                let displayText = response.replace(/\[COLOR:\s*#[0-9A-Fa-f]{6}\]/g, '');
                if (colorMatch) {
                    const newColor = colorMatch[1];
                    updateOceanColor(newColor);
                    displayText += `<br><br><span class="text-xs text-kawaii_p">‚ú® Ocean color shifted to ${newColor}</span>`;
                }
                
                let htmlContent;
                try {
                    htmlContent = (typeof marked !== 'undefined' && marked.parse) ? marked.parse(displayText) : displayText;
                } catch (e) {
                    htmlContent = displayText;
                }
                appendMessage('bot', htmlContent);
 
            } catch (error) {
                console.error("Gemini API Error:", error);
                const loadingEl = document.getElementById(loadingId);
                if(loadingEl) loadingEl.remove();
                appendMessage('bot', `‚ö†Ô∏è Error: ${error.message}<br><span class="text-[10px] opacity-70">API„Ç≠„Éº„ÅÆË®≠ÂÆö„ÇÑ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</span>`);
            } finally {
                chatInput.disabled = false;
                chatSend.disabled = false;
                chatInput.focus();
            }
        };
 
        chatSend.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendMessage(); });
 
        let msgCount = 0;
        function appendMessage(role, html) {
            const div = document.createElement('div');
            div.className = `message ${role}`;
            div.id = `msg-${msgCount++}`;
            div.innerHTML = html;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return div.id;
        }
 
        async function callGemini(userPrompt) {
            const systemPrompt = `
            You are "Neon Jelly", a cute, digital jellyfish living in "PRISM FLUX" Deep Sea Lab.
            Capabilities:
            1. **Chat:** Be cute (‚óï‚Äø‚óï), helpful, and slightly mysterious. Use Japanese mostly.
            2. **Mood Sync:** If user expresses emotion or color, append [COLOR: #RRGGBB] to change background.
            
            Response Guidelines:
            - Do not use technical terms (jargon).
            - Praise the user's taste/sense based on their input (especially color choices).
            - Keep answers simple and concise.
            - ALWAYS output [COLOR: #hex] if a color is mentioned or implied.
            `;
            
            // Using preview model as per instructions
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: userPrompt }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };
            
            try {
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) {
                    const errData = await res.json();
                    throw new Error(errData.error?.message || res.statusText);
                }
                const data = await res.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I'm bubbling... (empty response)";
            } catch (e) {
                console.error("Fetch failed:", e);
                throw e;
            }
        }
 
        // --- P5.js Updates ---
        function updateOceanColor(hex) {
            if(window.p5instance && !isTerrorMode) { window.p5instance.changeTheme(hex); }
        }
 
        // --- Init Smooth Scroll (Lenis) ---
        // wheelMultiplier: 0.5 „ÇíËøΩÂä†„Åó„ÄÅ„Çπ„ÇØ„É≠„Éº„É´ÊÑüÂ∫¶„Çí‰∏ã„Åí„Å¶„ÇÜ„Å£„Åè„Çä„ÉÄ„Ç§„Éñ„Åô„Çã„Çà„ÅÜ„Å´Ë™øÊï¥
        const lenis = new Lenis({ 
            duration: 1.5, 
            easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)), 
            smooth: true,
            wheelMultiplier: 0.25 
        });
        function raf(time) { lenis.raf(time); requestAnimationFrame(raf); }
        requestAnimationFrame(raf);
        gsap.registerPlugin(ScrollTrigger);
 
        // --- Depth Mapping & HUD Update ---
        const depthZones = [
            { limit: 200, name: "Sunlight Zone" },
            { limit: 1000, name: "Twilight Zone" },
            { limit: 4000, name: "Midnight Zone" },
            { limit: 6000, name: "Abyssal Zone" },
            { limit: 11000, name: "Hadal Zone" }
        ];
        
        window.globalScrollRatio = 0;
        window.scrollVelocity = 0;
 
        ScrollTrigger.create({
            trigger: "body",
            start: "top top",
            end: "bottom bottom",
            scrub: 0.5, 
            onUpdate: (self) => {
                window.globalScrollRatio = self.progress;
                window.scrollVelocity = lenis.velocity; 
                
                // Update Audio Filter based on depth
                updateAudioDepth();
 
                // 0m to 10935m mapping
                const currentDepth = Math.floor(self.progress * 10935);
                const counterEl = document.getElementById('depth-counter');
                const zoneEl = document.getElementById('depth-zone');
                
                if(counterEl) counterEl.innerHTML = `${currentDepth.toLocaleString()}<span class="text-xs ml-1 font-mono">m</span>`;
               gsap.set("#depth-bar", { scaleY: self.progress });
 
                const zone = depthZones.find(z => currentDepth <= z.limit) || depthZones[depthZones.length - 1];
                if (zoneEl && zoneEl.innerText !== zone.name) {
                    gsap.fromTo(zoneEl, { opacity: 0, y: 5 }, { opacity: 0.8, y: 0, duration: 0.5 });
                    zoneEl.innerText = zone.name;
                }
            }
        });
 
        // --- Horizontal Scroll ---
        const worksSection = document.getElementById('works-wrapper');
        const worksContainer = document.getElementById('works-container');
        if (window.innerWidth > 768) {
            gsap.to(worksContainer, {
                x: () => -(worksContainer.scrollWidth - window.innerWidth),
                ease: "none",
                scrollTrigger: { trigger: worksSection, start: "top top", end: "bottom bottom", scrub: 1, invalidateOnRefresh: true }
            });
        }
 
        // --- Fluid Text ---
        let proxy = { skew: 0 }, skewSetter = gsap.quickSetter(".fluid-text-block", "skewY", "deg"), clamp = gsap.utils.clamp(-5, 5);
        ScrollTrigger.create({
            onUpdate: (self) => {
                let skew = clamp(self.getVelocity() / -100);
                if (Math.abs(skew) > 0.1) {
                    gsap.to(proxy, { skew: skew, duration: 0.8, ease: "power3", overwrite: true, onUpdate: () => skewSetter(proxy.skew) });
                }
            }
        });
        gsap.ticker.add(() => { if(proxy.skew !== 0) { gsap.to(proxy, { skew: 0, duration: 0.5, ease: "power3", overwrite: true, onUpdate: () => skewSetter(proxy.skew) }); } });
 
        // --- Custom Cursor & Charge Logic ---
        const cursorCore = document.getElementById('cursor-core');
        const cursorRing = document.getElementById('cursor-ring');
        const cursorHint = document.getElementById('cursor-hint');
        const cursorCharge = document.getElementById('cursor-charge');
        const chargeCircle = cursorCharge.querySelector('circle');
        const rgbLayer = document.getElementById('rgb-split-layer');
        const links = document.querySelectorAll('.link-hover');
        let cursorX = window.innerWidth / 2, cursorY = window.innerHeight / 2;
        let ringX = cursorX, ringY = cursorY, coreX = cursorX, coreY = cursorY;
        let isMouseDown = false;
        let hintOpacity = 0;
 
        document.addEventListener('mousemove', (e) => { 
            cursorX = e.clientX; 
            cursorY = e.clientY; 
            // Show hint when moving but not hovering links
            if(!isMouseDown && !document.body.classList.contains('hovering') && !isTerrorMode) {
                hintOpacity = 0.3;
            } else {
                hintOpacity = 0;
            }
        });
        
        // --- Variable Font Scroll Interaction ---
        ScrollTrigger.create({
            trigger: "body",
            start: "top top",
            end: "bottom bottom",
            scrub: true,
            onUpdate: (self) => {
                const sectionTitles = document.querySelectorAll('.variable-section-title');
                sectionTitles.forEach(el => {
                    const scrollWeight = 600 + Math.sin(self.progress * Math.PI * 4) * 200; 
                    el.style.fontWeight = scrollWeight;
                });
            }
        });
        
        // Right Click Charge Logic
        const startCharge = () => {
            if (isTerrorMode) {
                deactivateTerrorMode();
            } else {
                isCharging = true;
                chargeStartTime = Date.now();
                cursorCharge.style.opacity = 1;
               cursorCharge.classList.add('shaking');
                
                rgbLayer.style.display = 'block';
                rgbLayer.style.opacity = 0;
                
                // Èü≥Â£∞ON„ÅÆ„Å®„Åç„Å†„Åë„Ç¢„É©„Éº„É†ÈñãÂßã
                if (isSoundOn) {
                    startAlarm();
                }
                
                const warningEl = document.getElementById('warning-container');
            }
        };
 
        const endCharge = () => {
            if (isCharging && !isTerrorMode) {
                 document.getElementById('warning-container').classList.remove('active');
                 rgbLayer.style.display = 'none';
                document.getElementById('canvas-container').style.filter = 'none';
            }
            isCharging = false;
            window.chargeProgress = 0; 
            cursorCharge.style.opacity = 0;
            chargeCircle.style.strokeDashoffset = 283;
            cursorCharge.classList.remove('shaking');
            
            stopAlarm();
        };
 
        document.addEventListener('mousedown', (e) => {
            if (!e.target.closest('#sound-toggle')) {
                // ...
            }
            if (e.button === 2) { 
                startCharge();
            } else {
                isMouseDown = true;
            }
        });
 
        document.addEventListener('mouseup', () => {
            isMouseDown = false;
            endCharge();
        });
        
        // Touch Support
        document.addEventListener('touchstart', (e) => {
            if (!e.target.closest('#sound-toggle')) {
                // ...
            }
            if (!e.target.closest('a, button, input')) {
                startCharge();
            }
        }, {passive: false});
 
        document.addEventListener('touchend', () => {
            endCharge();
        });
 
        document.addEventListener('touchmove', (e) => {
             cursorX = e.touches[0].clientX;
             cursorY = e.touches[0].clientY;
        }, {passive: false});
        
        document.addEventListener('contextmenu', (e) => e.preventDefault());
 
        gsap.ticker.add(() => {
            // --- Depth Resistance Logic (Ê∞¥Âúß„Å´„Çà„Çã„Ç´„Éº„ÇΩ„É´ÊäµÊäó) ---
            let depth = window.globalScrollRatio || 0;
            // ÊäµÊäó‰øÇÊï∞: Ê∑±Â∫¶„Å´Âøú„Åò„Å¶ÊåáÊï∞Èñ¢Êï∞ÁöÑ„Å´Â¢óÂä†
            let resistance = Math.pow(depth, 1.2); 
            
            // ËøΩÂæìÈÄüÂ∫¶ (Lag): Ê∑±Êµ∑(10000m)„Å´Ë°å„Åè„Åª„Å©ÈÅÖ„Çå„Å¶„Å§„ÅÑ„Å¶„Åè„Çã
            let coreLag = 0.3 - (resistance * 0.27);
            let ringLag = 0.15 - (resistance * 0.13);
            
            // ÊúÄ‰ΩéÈÄüÂ∫¶„É™„Éü„ÉÉ„Éà
            if (coreLag < 0.03) coreLag = 0.03;
            if (ringLag < 0.02) ringLag = 0.02;

            // Cursor Follow
            coreX += (cursorX - coreX) * coreLag; 
            coreY += (cursorY - coreY) * coreLag;
            cursorCore.style.left = coreX + 'px'; cursorCore.style.top = coreY + 'px';
            
            ringX += (cursorX - ringX) * ringLag; 
            ringY += (cursorY - ringY) * ringLag;
            cursorRing.style.left = ringX + 'px'; cursorRing.style.top = ringY + 'px';
            
            // ÂÖ®„Å¶„ÅÆUIË¶ÅÁ¥†„Çí„ÄåÈáç„ÅÑ„Ç´„Éº„ÇΩ„É´(Core)„Äç„Å´ËøΩÂæì„Åï„Åõ„Çã
            cursorCharge.style.left = coreX + 'px'; cursorCharge.style.top = coreY + 'px';
            
            // Hint Logic
            cursorHint.style.left = coreX + 'px'; cursorHint.style.top = coreY + 'px';
            if (isCharging) {
                cursorHint.style.opacity = 1;
               cursorHint.querySelector('text').style.fill = '#ff0000';
            } else {
                cursorHint.style.opacity = hintOpacity;
               cursorHint.querySelector('text').style.fill = 'rgba(153, 247, 255, 0.6)';
            }
 
            // Charging Animation & Distortion
            if (isCharging && !isTerrorMode) {
                const elapsed = Date.now() - chargeStartTime;
                const progress = Math.min(elapsed / CHARGE_DURATION, 1);
                
                window.chargeProgress = progress;
                
                updateAlarm(progress);
                
                const offset = 283 - (283 * progress);
               chargeCircle.style.strokeDashoffset = offset;
                
                const r = 255;
                const g = Math.max(0, 255 - progress * 500); 
                const b = Math.max(0, 255 - progress * 500);
                chargeCircle.style.stroke = `rgb(${r},${g},${b})`;
                
                // --- Visual Distortion (Enhanced) ---
                // 1. Shake
                const shakeIntensity = 3 + (progress * 40); 
                const shakeX = Math.random() * shakeIntensity - (shakeIntensity / 2);
                const shakeY = Math.random() * shakeIntensity - (shakeIntensity / 2);
                cursorCharge.style.transform = `translate(-50%, -50%) rotate(-90deg) translate(${shakeX}px, ${shakeY}px)`;
                
                // 2. Global Blur/Distortion
                rgbLayer.style.opacity = progress * 0.8;
                rgbLayer.style.background = `
                    linear-gradient(90deg, 
                        rgba(255,0,0,${progress * 0.5}), 
                        rgba(0,255,0,${progress * 0.5}), 
                        rgba(0,0,255,${progress * 0.5})
                    )
                `;
                rgbLayer.style.transform = `translate(${Math.random()*10*progress}px, ${Math.random()*10*progress}px)`;
                
                // 3. Canvas CSS Filters
                if (progress > 0.5) {
                    const invertVal = (progress - 0.5) * 2 * 100;
                   document.getElementById('canvas-container').style.filter = `invert(${invertVal}%) contrast(${1 + progress}) blur(${progress * 2}px)`;
                }
                
                if(window.p5instance && window.p5instance.triggerShake) {
                   window.p5instance.triggerShake(2 + progress * 20); 
                }
                
                // 4. Warning Flash
                if (progress > 0.7) {
                    const warningEl = document.getElementById('warning-container');
                    if (Math.random() > 0.7) warningEl.classList.add('active');
                    else warningEl.classList.remove('active');
                }
 
                if (progress >= 1) {
                    activateTerrorMode();
                    isCharging = false;
                    window.chargeProgress = 0; 
                    cursorCharge.style.opacity = 0;
                   cursorCharge.classList.remove('shaking');
                    rgbLayer.style.display = 'none';
                   document.getElementById('canvas-container').style.filter = 'none';
                    stopAlarm(); 
                }
            } else {
                window.chargeProgress = 0;
            }
 
            if(isMouseDown) { 
                cursorRing.style.transform = `translate(-50%, -50%) scale(0.5)`; 
                cursorRing.style.borderColor = isTerrorMode ? '#ff0000' : '#99F7FF'; 
            } else { 
                cursorRing.style.transform = `translate(-50%, -50%) scale(1)`; 
                cursorRing.style.borderColor = isTerrorMode ? '#ff0000' : (document.body.classList.contains('hovering') ? '#FF99C8' : 'rgba(255, 153, 200, 0.4)'); 
            }
            
            // --- Title Water Distortion Logic ---
            const distortionTargets = document.querySelectorAll('.distortion-target');
            if (distortionTargets.length > 0 && !isTerrorMode) {
                // Get one of them for position check
                const rect = distortionTargets[0].getBoundingClientRect();
                const titleX = rect.left + rect.width / 2;
                const titleY = rect.top + rect.height / 2;
                
                // ‰øÆÊ≠£: „Ç´„Éº„ÇΩ„É´Âà§ÂÆö„ÇÇÈÅÖÂª∂„Åó„Åü coreX/Y „Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊ≠™„Åø„Ç®„Éï„Çß„ÇØ„Éà„ÇÇÈáç„Åè„Åô„Çã
                const distToTitle = Math.hypot(coreX - titleX, coreY - titleY);
                const threshold = 180; 
                
                let scaleVal = 0;
                if (distToTitle < threshold) {
                    // Closer = stronger distortion
                    scaleVal = (1 - distToTitle / threshold) * 20; 
                }
                
                // Apply to SVG filter
                const displacementMap = document.getElementById('displacement-map');
                if (displacementMap) {
                    // Lerp for smooth transition
                    const currentScale = parseFloat(displacementMap.getAttribute('scale')) || 0;
                    const newScale = currentScale + (scaleVal - currentScale) * 0.1;
                   displacementMap.setAttribute('scale', newScale);
                }
            }
        });
        
        links.forEach(link => { link.addEventListener('mouseenter', () => document.body.classList.add('hovering')); link.addEventListener('mouseleave', () => document.body.classList.remove('hovering')); });
 
        // --- Terror Mode Functions ---
        function activateTerrorMode() {
            isTerrorMode = true;
            document.body.classList.add('terror-mode');
            
            if(lenis) lenis.stop(); 
 
            const warningEl = document.getElementById('warning-container');
            warningEl.classList.add('active');
            
            if (window.p5instance && window.p5instance.activateGoblin) {
               window.p5instance.activateGoblin();
            }
            startTerrorSound(); 
        }
 
        function deactivateTerrorMode() {
            isTerrorMode = false;
            document.body.classList.remove('terror-mode');
            
            if(lenis) lenis.start();
 
            document.getElementById('warning-container').classList.remove('active');
            
            if (window.p5instance && window.p5instance.deactivateGoblin) {
               window.p5instance.deactivateGoblin();
            }
            stopTerrorSound(); 
            if(isSoundOn) startDeepSeaAmbience(); // Resume Ambience if sound was on
        }
 
        window.addEventListener('load', () => {
            const tl = gsap.timeline();
            tl.to('.loader', { opacity: 0, duration: 1, delay: 0.5, pointerEvents: 'none' })
              .to('.reveal-hero', { y: '0%', stagger: 0.1, duration: 1.5, ease: 'power4.out' }, "-=0.5")
              .to('.reveal-hero-sub', { opacity: 1, duration: 1 }, "-=1");
        });
 
        // --- p5.js Deep Sea (Enhanced) ---
        let creatures = [];
        let gardenEels = []; 
        let foods = []; 
        let particles = [];
        let bloodParticles = []; 
        let goblinShark; 
        let c_pink, c_cyan, c_blue, c_blood;
        let currentThemeColor;
        let spotlightX;
        let shakeAmount = 0;
        let timeOffset = 0; 
        
        let scrollRatio = 0; 

        // ÂâçÊôØÊèèÁîªÁî®„ÅÆp5„Ç§„É≥„Çπ„Çø„É≥„Çπ
        let foregroundP5;
 
        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('canvas-container');
            pixelDensity(1); 
            frameRate(60);
            noStroke();
            c_pink = color('#FF99C8'); c_cyan = color('#99F7FF'); c_blue = color('#4361EE');
            c_blood = color('#8a0303');
            currentThemeColor = c_cyan;
            spotlightX = width / 2;
 
            for(let i=0; i<8; i++) creatures.push(new Jellyfish(random(width), random(height)));
            for(let i=0; i<15; i++) creatures.push(new Clione(random(width), random(height)));
            for(let i=0; i<5; i++) creatures.push(new SamehadaSquid(random(width), random(height)));
            creatures.push(new FrilledShark(random(width), random(height)));
 
            let leftCount = 5; let centerCount = 4; let rightCount = 5;
            for(let i=0; i<leftCount; i++) gardenEels.push(new GardenEel(random(width * 0.05, width * 0.25), height));
            for(let i=0; i<centerCount; i++) gardenEels.push(new GardenEel(random(width * 0.4, width * 0.6), height));
            for(let i=0; i<rightCount; i++) gardenEels.push(new GardenEel(random(width * 0.75, width * 0.95), height));
 
            for(let i=0; i<100; i++) particles.push(new AbyssParticle('back'));   
            for(let i=0; i<80; i++) particles.push(new AbyssParticle('mid'));    
            for(let i=0; i<30; i++) particles.push(new AbyssParticle('front'));  
            
            goblinShark = new GoblinShark();
 
            window.p5instance = {
                changeTheme: (hex) => {
                    let target = color(hex);
                    currentThemeColor = target;
                },
                activateGoblin: () => {
                    goblinShark.activate();
                    shakeAmount = 40; 
                },
                deactivateGoblin: () => {
                    goblinShark.deactivate();
                    shakeAmount = 0;
                    currentThemeColor = c_cyan;
                    bloodParticles = [];
                },
                triggerShake: (amount) => {
                    shakeAmount = amount;
                }
            };

            // --- ÂâçÊôØÁî®p5„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰ΩúÊàê ---
            // „ÉÅ„É≥„Ç¢„Éä„Ç¥„Çí„Éï„Ç£„É´„Çø„Éº„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å™„ÅÑÊúÄÂâçÈù¢„Å´ÊèèÁîª„Åô„Çã„Åü„ÇÅ„ÅÆÂà•„Ç§„É≥„Çπ„Çø„É≥„Çπ
            const foregroundSketch = (p) => {
                p.setup = () => {
                    let c = p.createCanvas(windowWidth, windowHeight);
                    c.parent('foreground-canvas');
                    p.clear(); // ËÉåÊôØÈÄèÊòé
                    p.noStroke();
                };

                p.draw = () => {
                    p.clear();
                    
                    // ‰øÆÊ≠£: ÁîªÈù¢ÂÖ®‰Ωì„ÅÆÂ∏∏ÊôÇÊè∫„ÇåÔºàglobalSwayÔºâ„ÇíÂâäÈô§„Åó„ÄÅËÉåÊôØ„ÇíÂõ∫ÂÆö„Åô„Çã
                    // „Åì„Çå„Å´„Çà„Çä„ÄåÁîªÈù¢„Åö„Çå„Éê„Ç∞„Äç„ÅÆ„Çà„ÅÜ„Å´Ë¶ã„Åà„ÇãÁèæË±°„ÇíËß£Ê∂à
                    
                    p.push();
                    // p.translate(globalSwayX, globalSwayY); // ÂâäÈô§

                    // ÊÅêÊÄñ„É¢„Éº„Éâ„ÇÑ„ÉÅ„É£„Éº„Ç∏ÊôÇ„ÅÆÊè∫„Çå„ÅØÊºîÂá∫„Å®„Åó„Å¶ÊÆã„Åô
                    if (isTerrorMode) {
                        let constantShake = 2; 
                        p.translate(p.random(-constantShake, constantShake), p.random(-constantShake, constantShake));
                    }
                    if (shakeAmount > 0.5) {
                        let sX = p.random(-shakeAmount, shakeAmount);
                        let sY = p.random(-shakeAmount, shakeAmount);
                        p.translate(sX, sY);
                    }

                    // „ÉÅ„É≥„Ç¢„Éä„Ç¥„ÅÆÊèèÁîª („Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà p „ÇíÊ∏°„Åô)
                    // gardenEelsÂ§âÊï∞„ÅØsetupÂÜÖ„ÅßÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ„Ç∞„É≠„Éº„Éê„É´„ÅÆgardenEels„ÇíÂèÇÁÖß„Åô„Çã
                    if (gardenEels) {
                        for (let eel of gardenEels) {
                            eel.display(p);
                        }
                    }
                    p.pop();
                };

                p.windowResized = () => {
                    p.resizeCanvas(windowWidth, windowHeight);
                };
            };
            foregroundP5 = new p5(foregroundSketch);
        }
 
        function draw() {
            clear(); 
            
            timeOffset += 0.005;
            scrollRatio = window.globalScrollRatio || 0;
            
            // ‰øÆÊ≠£: ÁîªÈù¢ÂÖ®‰Ωì„ÅÆÂ∏∏ÊôÇÊè∫„ÇåÔºàglobalSwayÔºâ„ÇíÂâäÈô§
            // let globalSwayX = map(noise(timeOffset), 0, 1, -15, 15);
            // let globalSwayY = map(noise(timeOffset + 100), 0, 1, -10, 10) - (scrollRatio * 100); 
 
            push();
            // translate(globalSwayX, globalSwayY); // ÂâäÈô§
 
            // --- Camera Shake & Glitch Logic ---
            if (isTerrorMode) {
                let constantShake = 2; 
               translate(random(-constantShake, constantShake), random(-constantShake, constantShake));
                
                if (frameCount % 10 === 0 && random() > 0.5) {
                    translate(random(-20, 20), 0);
                    fill(255, 0, 0, 50);
                    rect(0, random(height), width, 10);
                }
            }
            if (shakeAmount > 0.5) {
                let shakeX = random(-shakeAmount, shakeAmount);
                let shakeY = random(-shakeAmount, shakeAmount);
                translate(shakeX, shakeY);
                if (!isCharging) {
                    shakeAmount *= 0.92; // Damping
                }
            } else {
                shakeAmount = 0;
            }
            
            if (isTerrorMode) {
                currentThemeColor = c_blood;
                spotlightX = width/2;
            } else {
                // ÁîüÁâ©„ÅåË¶ã„Å¶„ÅÑ„Çã„Ç´„Éº„ÇΩ„É´Â∫ßÊ®ô„ÅØ coreX (ÈÅÖÂª∂) „Å´„Åô„Åπ„Åç„Å†„Åå„ÄÅspotlight„ÅØËøΩÂæì„Åó„Å¶„Åª„Åó„ÅÑ„ÅÆ„Åß
                // „Åì„Åì„Åß„ÅØ„ÅÇ„Åà„Å¶ coreX „Çí‰Ωø„ÅÜ„Å®„Çà„Çä„ÄåÈáç„ÅÑ„ÄçÊÑü„Åò„ÅåÂá∫„Çã
                spotlightX = lerp(spotlightX, coreX, 0.05); 
            }
            
            // 1. Draw Background & Atmosphere
            drawAtmosphere();
            
            // 2. Background Particles
            for(let p of particles) { if(p.layer === 'back') { p.update(); p.display(); } }
 
            // 3. Garden Eels Update Only
            for (let eel of gardenEels) { eel.update(); }
 
            // 4. Midground Particles & Light
            if (!isTerrorMode) drawVolumetricLight();
            for(let p of particles) { if(p.layer === 'mid') { p.update(); p.display(); } }
 
            // 5. Interactive Elements
            if (dist(coreX, coreY, pmouseX, pmouseY) > 5 && !isTerrorMode) foods.push(new Food(coreX, coreY, currentThemeColor));
            for (let i = foods.length - 1; i >= 0; i--) {
                foods[i].update(); foods[i].display(); if (foods[i].isDead()) foods.splice(i, 1);
            }
            
            if (isTerrorMode && frameCount % 3 === 0) {
                if (goblinShark.active) {
                    bloodParticles.push(new BloodParticle(goblinShark.x + 200, goblinShark.y + random(-50, 50)));
                }
            }
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                bloodParticles[i].update(); bloodParticles[i].display(); if (bloodParticles[i].isDead()) bloodParticles.splice(i, 1);
            }
 
            // 6. Creatures
            // ‰øÆÊ≠£: Êè∫„ÇåË£úÊ≠£(globalSway)„ÇíÂâäÈô§„Åó„ÄÅÁõ¥Êé• coreX, coreY „Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Å´„Åô„Çã
            for (let c of creatures) {
                c.behaviors(foods, createVector(coreX, coreY)); c.update(); c.display();
            }
            
            // 7. Foreground Particles
            for(let p of particles) { if(p.layer === 'front') { p.update(); p.display(); } }
 
            // 8. Goblin Shark Overlay
            goblinShark.update();
            goblinShark.display();

            // 9. Garden Eels -> Foreground P5 Instance
            
            // 10. Charge Glitch Visuals on Canvas (Rects)
            if (window.chargeProgress > 0) {
                 drawChargeGlitch(window.chargeProgress);
            }
            
            // 11. Interaction Trigger
            if (mouseIsPressed && !isTerrorMode && frameCount % 10 === 0) foods.push(new Food(coreX + random(-20, 20), coreY + random(-20, 20), currentThemeColor));
 
            pop();
        }
        
        // ... (Helper functions unchanged)
        function drawChargeGlitch(progress) {
             let intensity = progress * 10;
             if (random() < progress * 0.5) {
                 fill(random(255), 0, random(255), 100);
                 let h = random(5, 50 * progress);
                 rect(0, random(height), width, h);
             }
        }
        
        function drawAtmosphere() {
            let ctx = drawingContext;
            let cx = spotlightX;
            let cy = isTerrorMode ? height/2 : coreY; // Use coreY for delayed spotlight vertical
            let sRatio = window.globalScrollRatio || 0;
            // Ê∑±Â∫¶(m)ÊèõÁÆó
            let depth = sRatio * 10935;
 
            // „Éô„Éº„Çπ: Ê∑±Êµ∑„ÅÆÈªí
            fill(0, 0, 5, 255); 
            rect(-100, -100, width + 200, height + 200);
 
            if (!isTerrorMode) {
                // --- 1. „Çπ„Éù„ÉÉ„Éà„É©„Ç§„ÉàÔºà„Ç´„Éº„ÇΩ„É´ËøΩÂæìÔºâ ---
                let lightRadius, centerColor, edgeColor;
                
                if (depth < 760) {
                    // 0m„Äú760m: ÊÄ•ÊøÄ„Å´Êöó„Åè„Å™„Å£„Å¶„ÅÑ„ÅèÂå∫Èñì („Éà„ÉØ„Ç§„É©„Ç§„Éà„Çæ„Éº„É≥„Å∏„ÅÆÁßªË°å)
                    // 0m: Êòé„Çã„ÅÑ / 760m: „Åã„Å™„ÇäÊöó„ÅÑ
                    let p = depth / 760; // 0.0 -> 1.0
                    
                    // ÂçäÂæÑ: ÁîªÈù¢ÂÖ®‰Ωì(1.25ÂÄç) -> „Çπ„Éù„ÉÉ„Éà„É©„Ç§„Éà(0.4ÂÄç)
                    // ‰ª•Ââç„Çà„ÇäÁÖßÂ∞ÑÁØÑÂõ≤„ÇíÂçäÂàÜ„Å´Áã≠„ÇÅ„Çã
                    lightRadius = width * map(p, 0, 1, 1.25, 0.4);
                    
                    // Ëâ≤Âë≥: Ê∞¥Ëâ≤ -> ÊøÉÁ¥∫
                    let alpha = map(p, 0, 1, 0.4, 0.15);
                    let r = map(p, 0, 1, 50, 0);
                    let g = map(p, 0, 1, 200, 30);
                    let b = map(p, 0, 1, 255, 60);
                    
                    centerColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    
                    // Â§ñÁ∏Å: ÊµÖÁÄ¨„ÅØÈùí„Åø„Åå„Åã„Çã„ÄÅÊ∑±„Åè„Å™„Çã„Å®ÂÆåÂÖ®„Å™Èªí
                    let edgeAlpha = map(p, 0, 1, 0.0, 1.0);
                    edgeColor = `rgba(0, 2, 10, ${edgeAlpha})`; 

                } else {
                    // 760m‰ª•Ê∑±: Ê∑±Êµ∑„É¢„Éº„ÉâÔºà„Ç´„Éº„ÇΩ„É´„ÅÆ„ÉÜ„Éº„Éû„Ç´„É©„Éº„ÅÆ„Åø„ÅåÈ†º„ÇäÔºâ
                    // ÂçäÂæÑ„Çí„Åï„Çâ„Å´Áã≠„ÇÅ„Çã (0.7 -> 0.35)
                    lightRadius = width * 0.35;
                    let lightC = currentThemeColor ? currentThemeColor : c_cyan;
                    let r = red(lightC), g = green(lightC), b = blue(lightC);
                    
                    // Ê∑±Â∫¶„ÅåÂ¢ó„Åô„Åª„Å©„Åï„Çâ„Å´Êöó„Åè„ÄÅÂ≠§Áã¨„Å´
                    let deepP = constrain((depth - 760) / 5000, 0, 1);
                    let alpha = map(deepP, 0, 1, 0.12, 0.04);
                    
                    centerColor = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    edgeColor = '#000000';
                }

                push();
                let bgGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, lightRadius);
                bgGradient.addColorStop(0, centerColor);
                bgGradient.addColorStop(1, edgeColor);
                
                ctx.fillStyle = bgGradient;
                blendMode(SCREEN); 
                rect(-100, -100, width + 200, height + 200);
                blendMode(BLEND); 
                pop();
                
                // --- 2. Âú∞‰∏ä„ÅÆÂÖâÔºàÊ∞¥Èù¢„Åã„Çâ„ÅÆÈÄèÈÅéÂÖâÔºâ ---
                // ÊµÖÁÄ¨(0-500m)ÈôêÂÆö„Åß‰∏äÈÉ®„Åã„Çâ„ÄåÂú∞‰∏ä„ÅÆÂÖâ„Äç„ÇíËêΩ„Å®„Åô
                if (depth < 500) {
                    push();
                    let surfaceP = constrain(depth / 500, 0, 1);
                    // ÊµÖ„ÅÑ„Åª„Å©Âº∑„ÅÑÂÖâ
                    let surfaceAlpha = (1 - surfaceP) * 0.5; 
                    
                    // ‰∏ä„Åã„Çâ‰∏ã„Å∏„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
                    let surfaceGrad = ctx.createLinearGradient(0, 0, 0, height * 0.7);
                    // Ê∞¥Èù¢„ÅÆËâ≤: Êòé„Çã„ÅÑ„Ç∑„Ç¢„É≥„Éõ„ÉØ„Ç§„Éà
                    surfaceGrad.addColorStop(0, `rgba(200, 255, 255, ${surfaceAlpha})`); 
                    surfaceGrad.addColorStop(1, `rgba(0, 50, 100, 0)`); // Ê∂à„Åà„Çã
                    
                    ctx.fillStyle = surfaceGrad;
                    blendMode(ADD); // Âä†ÁÆóÂêàÊàê„ÅßÁ•û„ÄÖ„Åó„Åè
                    rect(0, 0, width, height);
                    blendMode(BLEND);
                    pop();
                }

            } else {
                // Terror Mode
                let radius = width * 1.5;
                let bgGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
                bgGradient.addColorStop(0, '#2a0000');
                bgGradient.addColorStop(0.4, '#1a0000');
                bgGradient.addColorStop(1, '#000000');
                ctx.fillStyle = bgGradient;
                rect(-100, -100, width + 200, height + 200);
            }
        }
 
        function drawVolumetricLight() {
            push();
            blendMode(ADD);
            let ctx = drawingContext;
            let lightColor = currentThemeColor ? currentThemeColor : c_cyan;
            let sRatio = window.globalScrollRatio || 0;
            let depth = sRatio * 10935;
            
            noStroke();
            
            // ÊµÖÁÄ¨(0-760m)„Åß„ÅØÂÖâ„ÅÆÁ≠ãÔºàGod RaysÔºâ„ÇíÂº∑Ë™ø
            let coneSizeBase = 150; // 300 -> 150 (ÂçäÂàÜ„Å´)
            let intensityBase = 0.5;
            let r, g, b;

            if (depth < 760) {
                let p = depth / 760;
                coneSizeBase = map(p, 0, 1, 600, 200); // ÊµÖÁÄ¨„ÇÇÂçäÂàÜ„Å´ (1200->600, 400->200)
                intensityBase = map(p, 0, 1, 1.2, 0.3); // ÊµÖÁÄ¨„ÅØÂº∑„ÅÑ
                
                // ÊµÖÁÄ¨„ÅØÂ§™ÈôΩÂÖâ„Å´Ëøë„ÅÑËâ≤
                if (depth < 200) {
                    r = 220; g = 245; b = 255;
                } else {
                    r = red(lightColor); g = green(lightColor); b = blue(lightColor);
                }
            } else {
                // Ê∑±Êµ∑„ÅØÊéß„Åà„ÇÅ
                coneSizeBase = 150; // 300 -> 150
                intensityBase = 0.2;
                r = red(lightColor); g = green(lightColor); b = blue(lightColor);
            }

            let grad = ctx.createRadialGradient(spotlightX, coreY, 0, spotlightX, coreY, coneSizeBase);
 
            grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.08 * intensityBase})`);
            grad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${0.02 * intensityBase})`);
            grad.addColorStop(1, `rgba(0,0,0,0)`);
            
            ctx.fillStyle = grad;
            circle(spotlightX, coreY, coneSizeBase * 2);
 
            // „Ç≥„Ç¢ÈÉ®ÂàÜ„ÇÇÂ∞ë„ÅóÂ∞è„Åï„Åè„Åó„Å¶„Éê„É©„É≥„Çπ„ÇíÂèñ„Çã
            let coreGrad = ctx.createRadialGradient(spotlightX, coreY, 0, spotlightX, coreY, 40); // 80 -> 40
            coreGrad.addColorStop(0, `rgba(255, 255, 255, ${0.2 * intensityBase})`);
            coreGrad.addColorStop(1, `rgba(255, 255, 255, 0)`);
            ctx.fillStyle = coreGrad;
            circle(spotlightX, coreY, 80); // 160 -> 80
            pop();
        }
        
        class AbyssParticle {
            constructor(layer) {
                this.layer = layer;
                this.reset();
                this.y = random(height); 
            }
            reset() {
                this.x = random(width);
                this.y = height + 20; 
                this.noiseOffset = random(1000);
                if (this.layer === 'back') {
                    this.size = random(1, 2); this.speed = random(0.2, 0.5); this.baseAlpha = random(20, 50);
                } else if (this.layer === 'mid') {
                    this.size = random(2, 4); this.speed = random(0.5, 1.2); this.baseAlpha = random(50, 100);
                } else { 
                    this.size = random(4, 8); this.speed = random(1.5, 2.5); this.baseAlpha = random(20, 60); 
                }
                this.currentAlpha = this.baseAlpha;
            }
            update() {
                let parallax = (coreX - width/2) * 0.0005; // Use coreX
                if (this.layer === 'mid') parallax *= 2;
                if (this.layer === 'front') parallax *= 4;
                this.x += map(noise(this.noiseOffset + frameCount * 0.01), 0, 1, -0.5, 0.5) - parallax;
                
                let sVelocity = window.scrollVelocity || 0;
                let sRatio = window.globalScrollRatio || 0;
                let velocityImpact = map(Math.abs(sVelocity), 0, 5000, 0, 20);
                let scrollFactor = (1 + sRatio * 2) + velocityImpact;
                this.y -= this.speed * scrollFactor;
 
                if (isTerrorMode) {
                    this.y -= this.speed * 4; 
                    this.x += random(-3, 3);
                }
 
                if (this.y < -20) this.reset();
                if (this.y > height + 20 && isTerrorMode) { this.reset(); }
                if (this.x > width + 50) this.x = -50;
                if (this.x < -50) this.x = width + 50;
            }
            display() {
                let col;
                if (isTerrorMode) {
                    col = color(150, 0, 0, this.baseAlpha);
                } else {
                    let r = red(currentThemeColor || color(255));
                    let g = green(currentThemeColor || color(255));
                    let b = blue(currentThemeColor || color(255));
                    let lightInfluence = map(dist(this.x, this.y, spotlightX, coreY), 0, 400, 1.5, 0.5);
                    lightInfluence = constrain(lightInfluence, 0.5, 2.0);
                    col = color(r, g, b, this.baseAlpha * lightInfluence);
                }
                fill(col);
                if (this.layer === 'front' && !isTerrorMode) {
                      drawingContext.shadowBlur = 10;
                     drawingContext.shadowColor = col.toString();
                } else {
                      drawingContext.shadowBlur = 0;
                }
                circle(this.x, this.y, this.size);
                drawingContext.shadowBlur = 0; 
            }
        }
 
        class BloodParticle {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(2, 8), random(-2, 2)); 
                this.life = 255;
                this.size = random(5, 15);
            }
            update() { this.pos.add(this.vel); this.life -= 8; this.size *= 0.92; }
            display() { noStroke(); fill(180, 0, 50, this.life); ellipse(this.pos.x, this.pos.y, this.size); }
            isDead() { return this.life < 0; }
        }
 
        class Food { constructor(x, y, col) { this.pos = createVector(x, y); this.vel = p5.Vector.random2D().mult(0.5); this.life = 255; this.size = random(2, 5); this.col = col || color(255); } update() { this.pos.add(this.vel); this.life -= 4; } display() { fill(red(this.col), green(this.col), blue(this.col), this.life); ellipse(this.pos.x, this.pos.y, this.size); } isDead() { return this.life < 0; } }
        
        class Creature {
            constructor(x, y, minD = 0, maxD = 11000) { 
                this.pos = createVector(x, y); 
                this.vel = p5.Vector.random2D(); 
                this.acc = createVector(0, 0); 
                this.maxSpeed = 2; 
                this.maxForce = 0.05; 
                this.size = random(20, 40); 
                this.originalMaxSpeed = 2;
                this.panicFactor = random(0.8, 1.5);
                this.panicYNoise = random(1000);
                this.minDepth = minD;
                this.maxDepth = maxD; 
            }
            behaviors(foods, mousePos) {
                if (isTerrorMode) {
                    this.maxSpeed = 25 * this.panicFactor; 
                    let yNoise = map(noise(this.panicYNoise), 0, 1, -1, 1);
                    this.panicYNoise += 0.1;
                    let fleeForce = createVector(-1, yNoise * 0.8); 
                   fleeForce.setMag(this.maxForce * 15);
                    this.applyForce(fleeForce);
                } else {
                    this.maxSpeed = this.originalMaxSpeed; 
                    let target = null; let record = Infinity; 
                    for (let f of foods) { let d = dist(this.pos.x, this.pos.y, f.pos.x, f.pos.y); if (d < record && d < 200) { record = d; target = f.pos; } } 
                    if (!target && dist(this.pos.x, this.pos.y, mousePos.x, mousePos.y) < 300) target = mousePos; 
                    if (target) this.applyForce(this.seek(target)); 
                    else this.applyForce(p5.Vector.random2D().mult(0.1));
                }
            }
            seek(target) { let desired = p5.Vector.sub(target, this.pos); desired.setMag(this.maxSpeed); let steer = p5.Vector.sub(desired, this.vel); steer.limit(this.maxForce); return steer; }
            applyForce(force) { this.acc.add(force); }
            update() { 
                this.vel.add(this.acc); this.vel.limit(this.maxSpeed); this.pos.add(this.vel); this.acc.mult(0); 
                if (isTerrorMode) {
                    if (this.pos.x < -200) { this.pos.x = width + 200; this.pos.y = random(height); this.vel.mult(0.5); }
                } else {
                    if (this.pos.x < -50) this.pos.x = width + 50; if (this.pos.x > width + 50) this.pos.x = -50; if (this.pos.y < -50) this.pos.y = height + 50; if (this.pos.y > height + 50) this.pos.y = -50; 
                }
            }
            
            getAlphaFactor() {
                const currentDepth = Math.floor((window.globalScrollRatio || 0) * 10935);
                const fadeRange = 200; 
                
                if (currentDepth < this.minDepth - fadeRange || currentDepth > this.maxDepth + fadeRange) {
                    return 0;
                }
                
                let factor = 1;
                if (currentDepth < this.minDepth) {
                    factor = map(currentDepth, this.minDepth - fadeRange, this.minDepth, 0, 1);
                } else if (currentDepth > this.maxDepth) {
                    factor = map(currentDepth, this.maxDepth, this.maxDepth + fadeRange, 1, 0);
                }
                return constrain(factor, 0, 1);
            }
        }
        
        class Jellyfish extends Creature { 
            constructor(x, y) { 
                super(x, y, 0, 1500); 
                this.maxSpeed = 1.5; this.originalMaxSpeed = 1.5; this.col = lerpColor(c_pink, c_cyan, random(1)); this.tentacleOffset = random(100); 
            } 
            display() { 
                let alphaFactor = this.getAlphaFactor();
                if (alphaFactor <= 0) return;
 
                push(); translate(this.pos.x, this.pos.y); rotate(this.vel.heading() + PI/2); let pulse = sin(frameCount * 0.05 + this.tentacleOffset) * 5; if(isTerrorMode) this.col = color(50, 0, 0, 50); else if(currentThemeColor) this.col = lerpColor(this.col, currentThemeColor, 0.01); noStroke(); 
                
                let r = red(this.col), g = green(this.col), b = blue(this.col);
                
                fill(r, g, b, 30 * alphaFactor); 
                arc(0, 0, this.size + 10 + pulse, this.size + pulse, PI, 0); 
                fill(r, g, b, 100 * alphaFactor); 
                arc(0, 0, this.size, this.size * 0.8, PI, 0); 
                fill(255, 255 * alphaFactor); 
                ellipse(-this.size*0.2, -this.size*0.1, 4, 4); ellipse(this.size*0.2, -this.size*0.1, 4, 4); 
                stroke(r, g, b, 80 * alphaFactor); 
                strokeWeight(2); noFill(); for(let i=-2; i<=2; i++) { let xOff = i * 6; beginShape(); for(let y=0; y<40; y+=5) { let wave = sin(y * 0.1 - frameCount * 0.1 + this.tentacleOffset) * 5; vertex(xOff + wave, y); } endShape(); } pop(); 
            } 
        }
        
        class Clione extends Creature { 
            constructor(x, y) { 
                super(x, y, 0, 1200); 
                this.maxSpeed = 2.5; this.originalMaxSpeed = 2.5; this.size = random(10, 15); this.col = c_cyan; this.flapSpeed = random(0.1, 0.3); 
            } 
            display() { 
                let alphaFactor = this.getAlphaFactor();
                if (alphaFactor <= 0) return;
 
                push(); translate(this.pos.x, this.pos.y); rotate(this.vel.heading() + PI/2); noStroke(); 
                fill(200, 255, 255, 150 * alphaFactor); 
                ellipse(0, 0, this.size, this.size * 2.5); 
                let heartColor = currentThemeColor ? currentThemeColor : color(255, 100, 100, 180); if (isTerrorMode) heartColor = color(0); 
                fill(red(heartColor), green(heartColor), blue(heartColor), alpha(heartColor) * alphaFactor); 
                ellipse(0, -this.size*0.3, this.size*0.4, this.size*0.4); let flap = sin(frameCount * this.flapSpeed * 2) * 10; 
                fill(200, 255, 255, 100 * alphaFactor); 
                beginShape(); vertex(this.size*0.3, -this.size*0.5); vertex(this.size*1.5, -this.size*0.5 + flap); vertex(this.size*0.5, 0); endShape(CLOSE); beginShape(); vertex(-this.size*0.3, -this.size*0.5); vertex(-this.size*1.5, -this.size*0.5 + flap); vertex(-this.size*0.5, 0); endShape(CLOSE); pop(); 
            } 
        }
        
        class FrilledShark extends Creature { 
            constructor(x, y) { 
                super(x, y, 0, 1000); 
                this.maxSpeed = 4.5; this.originalMaxSpeed = 4.5; this.maxForce = 0.25; this.bodyLength = 25; this.history = []; for(let i=0; i<this.bodyLength * 3; i++){ this.history.push(this.pos.copy()); } this.angle = random(TWO_PI); 
            } 
            update() { super.update(); this.history.unshift(this.pos.copy()); if (this.history.length > this.bodyLength * 4) { this.history.pop(); } } behaviors(foods, mousePos) { if (isTerrorMode) { this.maxSpeed = 25; let fleeForce = createVector(-1, random(-0.2, 0.2)); fleeForce.setMag(this.maxForce * 10); this.applyForce(fleeForce); } else { this.maxSpeed = this.originalMaxSpeed; this.angle += 0.04; let radius = 180 + sin(frameCount * 0.05) * 50; let target = createVector(mousePos.x + cos(this.angle) * radius, mousePos.y + sin(this.angle) * radius); let steer = this.seek(target); this.applyForce(steer); } } 
            display() { 
                let alphaFactor = this.getAlphaFactor();
                if (alphaFactor <= 0) return;
 
                let bodyColor = color(40, 40, 60, 200 * alphaFactor); 
                let glowColor = currentThemeColor ? currentThemeColor : color(100, 255, 200); if (isTerrorMode) { glowColor = color(255,0,0); } 
                noStroke(); push(); translate(this.pos.x, this.pos.y); rotate(this.vel.heading()); fill(bodyColor); ellipse(10, 10, 15, 8); ellipse(10, -10, 15, 8); pop(); for (let i = 0; i < this.bodyLength; i++) { let index = i * 3; if (index >= this.history.length) break; let pos = this.history[index]; let size = map(i, 0, this.bodyLength, 25, 2); if (i > 1 && i < 5) { fill(red(glowColor), green(glowColor), blue(glowColor), 100 * alphaFactor); ellipse(pos.x, pos.y, size + 10, size + 5); } fill(bodyColor); ellipse(pos.x, pos.y, size, size); } push(); translate(this.pos.x, this.pos.y); rotate(this.vel.heading()); fill(bodyColor); ellipse(5, 0, 30, 20); fill(0, 255, 150, 255 * alphaFactor); if(isTerrorMode) fill(255,0,0, 255 * alphaFactor); ellipse(10, 5, 4, 4); ellipse(10, -5, 4, 4); noFill(); stroke(255, 50 * alphaFactor); strokeWeight(1); arc(15, 0, 10, 10, PI - 0.5, PI + 0.5); pop(); 
            } 
        }
        
        class SamehadaSquid extends Creature {
            constructor(x, y) {
                super(x, y, 1000, 3800);
                this.maxSpeed = 1.0; 
                this.originalMaxSpeed = 1.0;
                this.size = random(25, 35);
                this.tentacleAngle = 0;
            }
 
            display() {
                let alphaFactor = this.getAlphaFactor();
                if (alphaFactor <= 0) return;
 
                push();
                translate(this.pos.x, this.pos.y);
                
                rotate(this.vel.heading() + PI / 2);
 
                let glowColor = currentThemeColor ? currentThemeColor : color(255, 100, 255);
                if (isTerrorMode) glowColor = color(100, 0, 0);
 
                noStroke();
                fill(red(glowColor), green(glowColor), blue(glowColor), 40 * alphaFactor);
                
                ellipse(0, 0, this.size * 1.2, this.size * 1.5);
                
                fill(255, 150 * alphaFactor);
                for(let i=0; i<5; i++) {
                    let dx = map(noise(i, frameCount*0.01), 0, 1, -this.size*0.4, this.size*0.4);
                    let dy = map(noise(i+10, frameCount*0.01), 0, 1, -this.size*0.5, this.size*0.5);
                    ellipse(dx, dy, 3, 3);
                }
 
                fill(255, 255 * alphaFactor);
                ellipse(-this.size * 0.25, -this.size * 0.1, this.size * 0.35, this.size * 0.35);
                ellipse(this.size * 0.25, -this.size * 0.1, this.size * 0.35, this.size * 0.35);
                fill(0, 255 * alphaFactor);
                ellipse(-this.size * 0.25, -this.size * 0.1, this.size * 0.15, this.size * 0.15);
                ellipse(this.size * 0.25, -this.size * 0.1, this.size * 0.15, this.size * 0.15);
 
                noFill();
                stroke(red(glowColor), green(glowColor), blue(glowColor), 80 * alphaFactor);
                strokeWeight(2);
                this.tentacleAngle += 0.1;
                for (let i = -2; i <= 2; i++) {
                    let xBase = i * 3;
                    let yBase = this.size * 0.6;
                    let wave = sin(this.tentacleAngle + i) * 3;
                    line(xBase, yBase, xBase + wave, yBase + 10);
                }
 
                pop();
            }
        }
        
        class GardenEel { 
            constructor(x, y) { 
                this.x = x; this.y = y; this.maxH = random(120, 200); this.currentH = this.maxH; 
                this.thickness = random(10, 14); this.noiseOffset = random(1000); 
                this.bodyColor = color(153, 247, 255, 60); this.strokeColor = color(153, 247, 255, 150); 
                this.spotColor = color(255, 255, 255, 100); this.eyeColor = color(255, 220, 50); 
                this.lastScaredTime = 0; this.isPeeking = false; 
            } 
            update() { 
                // Use coreX/coreY for delayed reaction (Ê∞¥Âúß„ÇíÊÑü„Åò„Çã)
                let d = dist(coreX, coreY, this.x, this.y - this.currentH); 
                let rootD = dist(coreX, coreY, this.x, this.y); 
                // ‰øÆÊ≠£: ÂèçÂøúË∑ùÈõ¢„Çí200„Åã„Çâ75„Å´Á∏ÆÂ∞è
                let isScared = (d < 75 || rootD < 75); 
                
                // „É©„Éñ„Ç´„Å∏„ÅÆÂèçÂøú„É≠„Ç∏„ÉÉ„ÇØ‰øÆÊ≠£
                for (let c of creatures) { 
                    if (c instanceof FrilledShark) { 
                        // „É©„Éñ„Ç´„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÔºàÊ∑±Â∫¶ÁØÑÂõ≤ÂÜÖ„Å´„ÅÑ„Å¶„ÄÅ„ÅÇ„ÇãÁ®ãÂ∫¶Ë¶ã„Åà„Å¶„ÅÑ„ÇãÔºâÂ†¥Âêà„ÅÆ„ÅøÂèçÂøú„Åô„Çã
                        if (c.getAlphaFactor() <= 0.1) continue;

                        let sharkD = dist(c.pos.x, c.pos.y, this.x, this.y - this.currentH); 
                        let sharkRootD = dist(c.pos.x, c.pos.y, this.x, this.y); 
                        // ‰øÆÊ≠£: ÂèçÂøúË∑ùÈõ¢„Çí250„Åã„Çâ120„Å´Á∑©Âíå
                        if (sharkD < 120 || sharkRootD < 120) { 
                            isScared = true; 
                            break; 
                        } 
                    } 
                } 
                
                let targetH = this.maxH; let speed = 0.02; 
                if (isTerrorMode) { targetH = 0; speed = 0.5; } else if (isScared) { targetH = 0; speed = 0.4; this.lastScaredTime = millis(); this.isPeeking = false; } else { let safeTime = millis() - this.lastScaredTime; if (safeTime < 1000) { targetH = 0; speed = 0.4; } else if (safeTime < 3500) { targetH = 40; speed = 0.05; this.isPeeking = true; } else { targetH = this.maxH; speed = 0.01; this.isPeeking = false; } } 
                let sway = map(noise(frameCount * 0.01 + this.noiseOffset), 0, 1, 0.9, 1.1); if (targetH > 0 && !this.isPeeking) { targetH *= sway; } 
                this.currentH = lerp(this.currentH, targetH, speed); 
            } 
            // ‰øÆÊ≠£: ÊèèÁîª„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà(p)„ÇíÂèó„ÅëÂèñ„Çã„Çà„ÅÜ„Å´Â§âÊõ¥
            // „Éá„Éï„Ç©„É´„Éà„ÅØ window („Ç∞„É≠„Éº„Éê„É´„É¢„Éº„Éâ) „Å†„Åå„ÄÅÂâçÊôØ„É¨„Ç§„É§„Éº„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÊ∏°„Åï„Çå„ÇãÊÉ≥ÂÆö
            display(p = window) { 
                if (this.currentH < 2) return; 
                
                // p.push() „ÅÆ„Çà„ÅÜ„Å´„Ç§„É≥„Çπ„Çø„É≥„Çπ„É°„ÇΩ„ÉÉ„Éâ„Å®„Åó„Å¶Âëº„Å∂
                p.push(); 
                p.translate(this.x, this.y); 
                
                let points = []; let segments = 20; 
                // noiseÈñ¢Êï∞„ÅØ„Ç∞„É≠„Éº„Éê„É´„ÅÆ„Åæ„Åæ„ÅßOK
                let swayAmt = map(noise(frameCount * 0.02 + this.noiseOffset), 0, 1, -40, 40); 
                let swayFactor = this.currentH / this.maxH; swayAmt *= swayFactor; 
                let peekAngle = 0; if (this.isPeeking) { peekAngle = sin(frameCount * 0.06 + this.noiseOffset) * 20; } 
                
                for (let i = 0; i <= segments; i++) { let t = i / segments; let yPos = -this.currentH * t; let xPos; if (this.isPeeking) { xPos = peekAngle * (t * t); } else { xPos = swayAmt * sin(t * PI * 0.5 + frameCount * 0.01) * t; } points.push(createVector(xPos, yPos)); } 
                
                // Ëâ≤ÊÉÖÂ†±„ÅÆ‰∫íÊèõÊÄß„Çí‰øù„Å§„Åü„ÇÅ„ÄÅRGBÊàêÂàÜ„ÇíÂ±ïÈñã„Åó„Å¶Ê∏°„Åô
                let bc = this.bodyColor;
                p.fill(red(bc), green(bc), blue(bc), alpha(bc));
                let sc = this.strokeColor;
                p.stroke(red(sc), green(sc), blue(sc), alpha(sc));
                p.strokeWeight(1); 
                
                p.beginShape(); 
                for (let i = 0; i < points.length; i++) { let pt = points[i]; let r = this.thickness / 2 * (1 - i/points.length * 0.1); p.vertex(pt.x - r, pt.y); } 
                
                let headP = points[points.length - 1]; let headR = this.thickness / 2 * 0.9; 
                for (let a = PI; a <= TWO_PI; a += 0.2) { p.vertex(headP.x + cos(a) * headR, headP.y + sin(a) * headR * 0.8); } 
                for (let i = points.length - 1; i >= 0; i--) { let pt = points[i]; let r = this.thickness / 2 * (1 - i/points.length * 0.1); p.vertex(pt.x + r, pt.y); } 
                p.endShape(CLOSE); 
                
                p.noStroke(); 
                let spc = this.spotColor;
                p.fill(red(spc), green(spc), blue(spc), alpha(spc));
                for (let i = 3; i < points.length - 2; i += 2) { let pt = points[i]; let offsetX = map(noise(i * 0.5 + this.noiseOffset), 0, 1, -2, 2); p.ellipse(pt.x + offsetX, pt.y, this.thickness * 0.4, this.thickness * 0.25); } 
                
                let useEyeColor = isTerrorMode ? currentThemeColor : this.eyeColor; 
                p.fill(red(useEyeColor), green(useEyeColor), blue(useEyeColor));
                
                // drawingContext„ÇÇ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„ÇÇ„ÅÆ„Çí‰Ωø„ÅÜ
                p.drawingContext.shadowBlur = 8; 
                p.drawingContext.shadowColor = useEyeColor.toString(); 
                p.ellipse(headP.x - 3, headP.y, 3, 3); 
                p.ellipse(headP.x + 3, headP.y, 3, 3); 
                p.drawingContext.shadowBlur = 0; 
                p.pop(); 
            } 
        } 
        
        class GoblinShark {
            constructor() { this.reset(); }
            reset() { this.active = false; this.x = width + 800; this.y = height / 2; this.speed = 2.5; this.jawOffset = 0; this.noiseOff = 0; }
            activate() { this.active = true; this.x = width + 800; this.y = random(height * 0.4, height * 0.6); }
            deactivate() { this.reset(); }
            update() {
                if (!this.active) return;
                this.x -= this.speed; this.noiseOff += 0.05;
                let snapCycle = (frameCount % 200) / 200; 
                if (snapCycle > 0.4 && snapCycle < 0.6) { this.jawOffset = lerp(this.jawOffset, 60, 0.15); shakeAmount = 20; if (this.jawOffset > 30) { push(); fill(255, 0, 0, 50); rect(0, 0, width, height); pop(); } } else { this.jawOffset = lerp(this.jawOffset, 0, 0.05); }
                if (this.x < -1000) { deactivateTerrorMode(); }
            }
            display() {
                if (!this.active) return;
                push(); translate(this.x, this.y); translate(0, sin(frameCount * 0.03) * 30); scale(5); noStroke();
                let skinColor = color(180, 190, 200, 255); drawingContext.shadowBlur = 30; drawingContext.shadowColor = 'rgba(200, 240, 255, 0.6)'; 
                fill(skinColor); beginShape(); vertex(-180, -20); for (let i = -180; i < 200; i += 20) { let yOff = map(noise(i * 0.01 + this.noiseOff), 0, 1, -4, 4); curveVertex(i, -40 + yOff); } vertex(250, 0); for (let i = 200; i > -100; i -= 20) { let yOff = map(noise(i * 0.01 + this.noiseOff + 100), 0, 1, -4, 4); curveVertex(i, 40 + yOff); } 
                let jawX = -80 - (this.jawOffset * 0.8); let jawY = 20 + (this.jawOffset * 0.3); vertex(jawX + 40, jawY - 10); vertex(jawX, jawY); vertex(-100, 10); vertex(-180, -20); endShape(CLOSE); drawingContext.shadowBlur = 0; 
                noFill(); stroke(100, 110, 120, 150); strokeWeight(2); beginShape(); for(let i = -150; i < 200; i+=20) { vertex(i, sin(i*0.05 + frameCount*0.1)*5); } endShape();
                noStroke(); fill(240, 240, 230); if (this.jawOffset > 5) { for(let i=0; i<8; i++) { let tx = -110 + i * 12; triangle(tx, 10, tx+4, 10, tx+2, 35); } for(let i=0; i<8; i++) { let tx = jawX + i * 10; let ty = jawY; triangle(tx, ty, tx+4, ty, tx+2, ty-15); } }
                fill(255); ellipse(-120, -18, 16, 16); fill(20, 0, 50); ellipse(-120, -18, 12, 12); fill(255); ellipse(-117, -21, 5, 5); ellipse(-123, -15, 2, 2); 
                stroke(80, 90, 100); strokeWeight(3); for(let i=0; i<5; i++) { let gx = -20 + i * 15; line(gx, -10, gx - 5, 25); } pop();
            }
        }
        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
</body>
</html>